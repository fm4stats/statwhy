(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require list.List.

(* Why3 assumption *)
Inductive scale :=
  | Nominal : scale
  | Ordinal : scale
  | Interval : scale
  | Rational : scale
  | Unspecified : scale.
Axiom scale_WhyType : WhyType scale.
Existing Instance scale_WhyType.

(* Why3 assumption *)
Inductive scale_leq: scale -> scale -> Prop :=
  | Scale_leq_nominal_ordinal : scale_leq Nominal Ordinal
  | Scale_leq_ordinal_interval : scale_leq Ordinal Interval
  | Scale_leq_interval_rational : scale_leq Interval Rational
  | Scale_leq_refl : forall (s:scale), scale_leq s s
  | Scale_leq_trans :
      forall (s:scale) (t:scale) (u:scale), scale_leq s t -> scale_leq t u ->
      scale_leq s u.

Axiom scale_leq_reflexive : forall (s:scale), scale_leq s s.

(* Why3 goal *)
Theorem scale_leq_antisymmetric :
  forall (s:scale) (t:scale), scale_leq s t -> scale_leq t s -> (s = t).
Proof.
  Require Import Lia.
  set (rank := fun s =>
                 match s with
                 | Nominal => 0
                 | Ordinal => 1
                 | Interval => 2
                 | Rational => 3
                 | Unspecified => 4
                 end).

  assert (mono: forall x y, scale_leq x y -> (rank x <= rank y)%nat).
  {
    intros x y H; induction H.
    - cbv; lia.
    - cbv; lia.
    - cbv; lia.
    - lia.
    - lia.
  }

  assert (inj: forall x y, rank x = rank y -> x = y).
  {
    intros x y H; destruct x; destruct y; try lia; cbv in H; try discriminate; reflexivity.
  }
  
  intros s t Hst Hts.
  
  assert (H1: rank s <= rank t).
  {
    apply mono.
    assumption.
  }
  
  assert (H2: rank t <= rank s).
  {
    apply mono.
    assumption.
  }
  
  assert (Heq: rank s = rank t).
  {
    apply Nat.le_antisymm; assumption.
  }
  
  apply inj.
  assumption.
Qed.

