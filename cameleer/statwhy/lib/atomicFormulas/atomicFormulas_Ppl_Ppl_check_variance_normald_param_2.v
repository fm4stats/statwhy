(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.Abs.
Require int.ComputerDivision.
Require real.Real.
Require real.RealInfix.
Require bool.Bool.
Require list.List.
Require list.Length.
Require list.Mem.
Require set.Fset.
Require list.Nth.
Require option.Option.
Require list.HdTl.
Require list.NthHdTl.
Require list.Append.
Require list.Reverse.
Require list.RevAppend.
Require list.Combine.
Require list.NumOcc.
Require list.Permut.

(* Why3 assumption *)
Fixpoint fold {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
  (f:b -> a -> b) (acc:b) (lst:Init.Datatypes.list a) {struct lst}: b :=
  match lst with
  | Init.Datatypes.nil => acc
  | Init.Datatypes.cons x r => fold f (f acc x) r
  end.

(* Why3 assumption *)
Fixpoint foldr {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
  (f:b -> a -> b) (acc:b) (lst:Init.Datatypes.list a) {struct lst}: b :=
  match lst with
  | Init.Datatypes.nil => acc
  | Init.Datatypes.cons x r => f (foldr f acc r) x
  end.

Axiom fold__append :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (l1:Init.Datatypes.list a) (l2:Init.Datatypes.list a)
    (f:b -> a -> b) (acc:b),
  ((fold f acc (Init.Datatypes.app l1 l2)) = (fold f (fold f acc l1) l2)).

(* Why3 assumption *)
Fixpoint map {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b} (f:a -> b)
  (lst:Init.Datatypes.list a) {struct lst}: Init.Datatypes.list b :=
  match lst with
  | Init.Datatypes.nil => Init.Datatypes.nil
  | Init.Datatypes.cons x xs => Init.Datatypes.cons (f x) (map f xs)
  end.

Parameter result:
  forall {a:Type} {a_WT:WhyType a}, (a -> Init.Datatypes.bool) ->
  Init.Datatypes.bool -> a -> Init.Datatypes.bool.

Axiom result'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (p:a -> Init.Datatypes.bool) (acc:Init.Datatypes.bool) (t:a),
  ((result p acc t) = Init.Datatypes.true) <->
  (acc = Init.Datatypes.true) /\ ((p t) = Init.Datatypes.true).

(* Why3 assumption *)
Definition for_all {a:Type} {a_WT:WhyType a} (p:a -> Init.Datatypes.bool)
    (l:Init.Datatypes.list a) : Init.Datatypes.bool :=
  fold (result p) Init.Datatypes.true l.

Axiom for_all_correctness :
  forall {a:Type} {a_WT:WhyType a},
  forall (p:a -> Init.Datatypes.bool) (l:Init.Datatypes.list a),
  ((for_all p l) = Init.Datatypes.true) <->
  (forall (x:a), list.Mem.mem x l -> ((p x) = Init.Datatypes.true)).

Parameter result1:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  (a -> b -> Init.Datatypes.bool) ->
  Init.Datatypes.bool -> (a* b)%type -> Init.Datatypes.bool.

Axiom result'def1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (p:a -> b -> Init.Datatypes.bool) (acc:Init.Datatypes.bool)
    (t:(a* b)%type),
  ((result1 p acc t) = Init.Datatypes.true) <->
  match t with
  | (x, y) => (acc = Init.Datatypes.true) /\ ((p x y) = Init.Datatypes.true)
  end.

(* Why3 assumption *)
Definition for_all2 {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (p:a -> b -> Init.Datatypes.bool) (l:Init.Datatypes.list a)
    (r:Init.Datatypes.list b) : Init.Datatypes.bool :=
  fold (result1 p) Init.Datatypes.true (Lists.List.combine l r).

Parameter result2:
  forall {a:Type} {a_WT:WhyType a}, (a -> Init.Datatypes.bool) ->
  Init.Datatypes.bool -> a -> Init.Datatypes.bool.

Axiom result'def2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (p:a -> Init.Datatypes.bool) (acc:Init.Datatypes.bool) (x:a),
  ((result2 p acc x) = Init.Datatypes.true) <->
  (acc = Init.Datatypes.true) \/ ((p x) = Init.Datatypes.true).

(* Why3 assumption *)
Definition for_some {a:Type} {a_WT:WhyType a} (p:a -> Init.Datatypes.bool)
    (l:Init.Datatypes.list a) : Init.Datatypes.bool :=
  fold (result2 p) Init.Datatypes.false l.

(* Why3 assumption *)
Definition mem_list {a:Type} {a_WT:WhyType a}
    (eq:a -> a -> Init.Datatypes.bool) (x:a) (l:Init.Datatypes.list a) :
    Init.Datatypes.bool :=
  for_some (eq x) l.

(* Why3 assumption *)
Definition rset := set.Fset.fset Reals.Rdefinitions.R.

(* Why3 assumption *)
Fixpoint fold_left {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
  (f:b -> a -> b) (acc:b) (l:Init.Datatypes.list a) {struct l}: b :=
  match l with
  | Init.Datatypes.nil => acc
  | Init.Datatypes.cons x r => fold_left f (f acc x) r
  end.

Axiom fold_left_append :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (l1:Init.Datatypes.list a) (l2:Init.Datatypes.list a)
    (f:b -> a -> b) (acc:b),
  ((fold_left f acc (Init.Datatypes.app l1 l2)) =
   (fold_left f (fold_left f acc l1) l2)).

Parameter concat:
  Strings.String.string -> Strings.String.string -> Strings.String.string.

Axiom concat_assoc :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (s3:Strings.String.string),
  ((concat (concat s1 s2) s3) = (concat s1 (concat s2 s3))).

Parameter rliteral: Strings.String.string.

Axiom rliteral_axiom : True.

Axiom concat_empty :
  forall (s:Strings.String.string),
  ((concat s rliteral) = (concat rliteral s)) /\ ((concat rliteral s) = s).

Parameter length: Strings.String.string -> Numbers.BinNums.Z.

Axiom length_empty : ((length rliteral) = 0%Z).

Axiom length_concat :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  ((length (concat s1 s2)) = ((length s1) + (length s2))%Z).

Parameter lt: Strings.String.string -> Strings.String.string -> Prop.

Axiom lt_empty :
  forall (s:Strings.String.string), ~ (s = rliteral) -> lt rliteral s.

Axiom lt_not_com :
  forall (s1:Strings.String.string) (s2:Strings.String.string), lt s1 s2 ->
  ~ lt s2 s1.

Axiom lt_ref : forall (s1:Strings.String.string), ~ lt s1 s1.

Axiom lt_trans :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (s3:Strings.String.string),
  lt s1 s2 /\ lt s2 s3 -> lt s1 s3.

Parameter le: Strings.String.string -> Strings.String.string -> Prop.

Axiom le_empty : forall (s:Strings.String.string), le rliteral s.

Axiom le_ref : forall (s1:Strings.String.string), le s1 s1.

Axiom lt_le :
  forall (s1:Strings.String.string) (s2:Strings.String.string), lt s1 s2 ->
  le s1 s2.

Axiom lt_le_eq :
  forall (s1:Strings.String.string) (s2:Strings.String.string), le s1 s2 ->
  lt s1 s2 \/ (s1 = s2).

Axiom le_trans :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (s3:Strings.String.string),
  le s1 s2 /\ le s2 s3 -> le s1 s3.

Parameter s_at:
  Strings.String.string -> Numbers.BinNums.Z -> Strings.String.string.

Axiom at_out_of_range :
  forall (s:Strings.String.string) (i:Numbers.BinNums.Z),
  (i < 0%Z)%Z \/ ((length s) <= i)%Z -> ((s_at s i) = rliteral).

Axiom at_empty :
  forall (i:Numbers.BinNums.Z), ((s_at rliteral i) = rliteral).

Axiom at_length :
  forall (s:Strings.String.string) (i:Numbers.BinNums.Z),
  let j := s_at s i in
  ((0%Z <= i)%Z /\ (i < (length s))%Z -> ((length j) = 1%Z)) /\
  (~ ((0%Z <= i)%Z /\ (i < (length s))%Z) -> ((length j) = 0%Z)).

Axiom concat_at :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  let s := concat s1 s2 in
  forall (i:Numbers.BinNums.Z),
  ((0%Z <= i)%Z /\ (i < (length s1))%Z -> ((s_at s i) = (s_at s1 i))) /\
  (((length s1) <= i)%Z /\ (i < (length s))%Z ->
   ((s_at s i) = (s_at s2 (i - (length s1))%Z))).

Parameter substring:
  Strings.String.string -> Numbers.BinNums.Z -> Numbers.BinNums.Z ->
  Strings.String.string.

Axiom substring_out_of_range :
  forall (s:Strings.String.string) (i:Numbers.BinNums.Z)
    (x:Numbers.BinNums.Z),
  (i < 0%Z)%Z \/ ((length s) <= i)%Z -> ((substring s i x) = rliteral).

Axiom substring_of_length_zero_or_less :
  forall (s:Strings.String.string) (i:Numbers.BinNums.Z)
    (x:Numbers.BinNums.Z),
  (x <= 0%Z)%Z -> ((substring s i x) = rliteral).

Axiom substring_of_empty :
  forall (i:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  ((substring rliteral i x) = rliteral).

Axiom substring_smaller :
  forall (s:Strings.String.string) (i:Numbers.BinNums.Z)
    (x:Numbers.BinNums.Z),
  ((length (substring s i x)) <= (length s))%Z.

Axiom substring_smaller_x :
  forall (s:Strings.String.string) (i:Numbers.BinNums.Z)
    (x:Numbers.BinNums.Z),
  (0%Z <= x)%Z -> ((length (substring s i x)) <= x)%Z.

Axiom substring_length :
  forall (s:Strings.String.string) (i:Numbers.BinNums.Z)
    (x:Numbers.BinNums.Z),
  (0%Z <= x)%Z /\ (0%Z <= i)%Z /\ (i < (length s))%Z ->
  (((length s) < (i + x)%Z)%Z ->
   ((length (substring s i x)) = ((length s) - i)%Z)) /\
  (~ ((length s) < (i + x)%Z)%Z -> ((length (substring s i x)) = x)).

Axiom substring_at :
  forall (s:Strings.String.string) (i:Numbers.BinNums.Z),
  ((s_at s i) = (substring s i 1%Z)).

Axiom substring_substring :
  forall (s:Strings.String.string) (ofs:Numbers.BinNums.Z)
    (len:Numbers.BinNums.Z) (ofs':Numbers.BinNums.Z) (len':Numbers.BinNums.Z),
  (0%Z <= ofs)%Z /\ (ofs <= (length s))%Z -> (0%Z <= len)%Z ->
  ((ofs + len)%Z <= (length s))%Z -> (0%Z <= ofs')%Z /\ (ofs' <= len)%Z ->
  (0%Z <= len')%Z -> ((ofs' + len')%Z <= len)%Z ->
  ((substring (substring s ofs len) ofs' len') =
   (substring s (ofs + ofs')%Z len')).

Axiom concat_substring :
  forall (s:Strings.String.string) (ofs:Numbers.BinNums.Z)
    (len:Numbers.BinNums.Z) (len':Numbers.BinNums.Z),
  (0%Z <= ofs)%Z /\ (ofs <= (length s))%Z -> (0%Z <= len)%Z ->
  ((ofs + len)%Z <= (length s))%Z -> (0%Z <= len')%Z ->
  (0%Z <= ((ofs + len)%Z + len')%Z)%Z /\
  (((ofs + len)%Z + len')%Z <= (length s))%Z ->
  ((concat (substring s ofs len) (substring s (ofs + len)%Z len')) =
   (substring s ofs (len + len')%Z)).

Parameter prefixof: Strings.String.string -> Strings.String.string -> Prop.

Axiom prefixof_substring :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  prefixof s1 s2 <-> (s1 = (substring s2 0%Z (length s1))).

Axiom prefixof_concat :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  prefixof s1 (concat s1 s2).

Axiom prefixof_empty :
  forall (s2:Strings.String.string), prefixof rliteral s2.

Axiom prefixof_empty2 :
  forall (s1:Strings.String.string), ~ (s1 = rliteral) ->
  ~ prefixof s1 rliteral.

Parameter suffixof: Strings.String.string -> Strings.String.string -> Prop.

Axiom suffixof_substring :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  suffixof s1 s2 <->
  (s1 = (substring s2 ((length s2) - (length s1))%Z (length s1))).

Axiom suffixof_concat :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  suffixof s2 (concat s1 s2).

Axiom suffixof_empty :
  forall (s2:Strings.String.string), suffixof rliteral s2.

Axiom suffixof_empty2 :
  forall (s1:Strings.String.string), ~ (s1 = rliteral) ->
  ~ suffixof s1 rliteral.

Parameter contains: Strings.String.string -> Strings.String.string -> Prop.

Axiom contains_prefixof :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  prefixof s1 s2 -> contains s2 s1.

Axiom contains_suffixof :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  suffixof s1 s2 -> contains s2 s1.

Axiom contains_empty :
  forall (s2:Strings.String.string), contains rliteral s2 <-> (s2 = rliteral).

Axiom contains_empty2 :
  forall (s1:Strings.String.string), contains s1 rliteral.

Axiom contains_substring :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (i:Numbers.BinNums.Z),
  ((substring s1 i (length s2)) = s2) -> contains s1 s2.

Axiom contains_concat :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  contains (concat s1 s2) s1 /\ contains (concat s1 s2) s2.

Axiom contains_at :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (i:Numbers.BinNums.Z),
  ((s_at s1 i) = s2) -> contains s1 s2.

Parameter indexof:
  Strings.String.string -> Strings.String.string -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z.

Axiom indexof_empty :
  forall (s:Strings.String.string) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= (length s))%Z -> ((indexof s rliteral i) = i).

Axiom indexof_empty1 :
  forall (s:Strings.String.string) (i:Numbers.BinNums.Z),
  let j := indexof rliteral s i in
  (j = (-1%Z)%Z) \/ (s = rliteral) /\ (i = j) /\ (j = 0%Z).

Axiom indexof_contains :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  let j := indexof s1 s2 0%Z in
  contains s1 s2 ->
  ((0%Z <= j)%Z /\ (j <= (length s1))%Z) /\
  ((substring s1 j (length s2)) = s2).

Axiom contains_indexof :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (i:Numbers.BinNums.Z),
  (0%Z <= (indexof s1 s2 i))%Z -> contains s1 s2.

Axiom not_contains_indexof :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (i:Numbers.BinNums.Z),
  ~ contains s1 s2 -> ((indexof s1 s2 i) = (-1%Z)%Z).

Axiom substring_indexof :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (i:Numbers.BinNums.Z),
  let j := indexof s1 s2 i in
  (0%Z <= j)%Z -> ((substring s1 j (length s2)) = s2).

Axiom indexof_out_of_range :
  forall (i:Numbers.BinNums.Z) (s1:Strings.String.string)
    (s2:Strings.String.string),
  ~ ((0%Z <= i)%Z /\ (i <= (length s1))%Z) -> ((indexof s1 s2 i) = (-1%Z)%Z).

Axiom indexof_in_range :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (i:Numbers.BinNums.Z),
  let j := indexof s1 s2 i in
  (0%Z <= i)%Z /\ (i <= (length s1))%Z ->
  (j = (-1%Z)%Z) \/ (i <= j)%Z /\ (j <= (length s1))%Z.

Axiom indexof_contains_substring :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (i:Numbers.BinNums.Z),
  ((0%Z <= i)%Z /\ (i <= (length s1))%Z) /\
  contains (substring s1 i ((length s1) - i)%Z) s2 ->
  (i <= (indexof s1 s2 i))%Z /\ ((indexof s1 s2 i) <= (length s1))%Z.

Parameter replace:
  Strings.String.string -> Strings.String.string -> Strings.String.string ->
  Strings.String.string.

Axiom replace_empty :
  forall (s1:Strings.String.string) (s3:Strings.String.string),
  ((replace s1 rliteral s3) = (concat s3 s1)).

Axiom replace_not_contains :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (s3:Strings.String.string),
  ~ contains s1 s2 -> ((replace s1 s2 s3) = s1).

Axiom replace_empty2 :
  forall (s2:Strings.String.string) (s3:Strings.String.string),
  let s4 := replace rliteral s2 s3 in
  ((s2 = rliteral) -> (s4 = s3)) /\ (~ (s2 = rliteral) -> (s4 = rliteral)).

Axiom replace_substring_indexof :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (s3:Strings.String.string),
  let j := indexof s1 s2 0%Z in
  ((j < 0%Z)%Z -> ((replace s1 s2 s3) = s1)) /\
  (~ (j < 0%Z)%Z ->
   ((replace s1 s2 s3) =
    (concat (concat (substring s1 0%Z j) s3)
     (substring s1 (j + (length s2))%Z (((length s1) - j)%Z - (length s2))%Z)))).

Parameter replaceall:
  Strings.String.string -> Strings.String.string -> Strings.String.string ->
  Strings.String.string.

Axiom replaceall_empty1 :
  forall (s1:Strings.String.string) (s3:Strings.String.string),
  ((replaceall s1 rliteral s3) = s1).

Axiom not_contains_replaceall :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (s3:Strings.String.string),
  ~ contains s1 s2 -> ((replaceall s1 s2 s3) = s1).

Parameter to_int: Strings.String.string -> Numbers.BinNums.Z.

Axiom to_int_gt_minus_1 :
  forall (s:Strings.String.string), ((-1%Z)%Z <= (to_int s))%Z.

Axiom to_int_empty : ((to_int rliteral) = (-1%Z)%Z).

(* Why3 assumption *)
Definition is_digit (s:Strings.String.string) : Prop :=
  ((0%Z <= (to_int s))%Z /\ ((to_int s) <= 9%Z)%Z) /\ ((length s) = 1%Z).

Parameter from_int: Numbers.BinNums.Z -> Strings.String.string.

Axiom from_int_negative :
  forall (i:Numbers.BinNums.Z), (i < 0%Z)%Z <-> ((from_int i) = rliteral).

Axiom from_int_to_int :
  forall (i:Numbers.BinNums.Z),
  ((0%Z <= i)%Z -> ((to_int (from_int i)) = i)) /\
  (~ (0%Z <= i)%Z -> ((to_int (from_int i)) = (-1%Z)%Z)).

Axiom char : Type.
Parameter char_WhyType : WhyType char.
Existing Instance char_WhyType.

Parameter contents: char -> Strings.String.string.

Axiom char'invariant : forall (self:char), ((length (contents self)) = 1%Z).

Axiom char_eq :
  forall (c1:char) (c2:char), ((contents c1) = (contents c2)) -> (c1 = c2).

Parameter code: char -> Numbers.BinNums.Z.

Axiom code1 : forall (c:char), (0%Z <= (code c))%Z /\ ((code c) < 256%Z)%Z.

Parameter chr: Numbers.BinNums.Z -> char.

Axiom code_chr :
  forall (n:Numbers.BinNums.Z), (0%Z <= n)%Z /\ (n < 256%Z)%Z ->
  ((code (chr n)) = n).

Axiom chr_code : forall (c:char), ((chr (code c)) = c).

Parameter get: Strings.String.string -> Numbers.BinNums.Z -> char.

Axiom get1 :
  forall (s:Strings.String.string) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length s))%Z -> ((contents (get s i)) = (s_at s i)).

Axiom substring_get :
  forall (s:Strings.String.string) (ofs:Numbers.BinNums.Z)
    (len:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= ofs)%Z /\ (ofs <= (length s))%Z -> (0%Z <= len)%Z ->
  ((ofs + len)%Z <= (length s))%Z -> (0%Z <= i)%Z /\ (i < len)%Z ->
  ((get (substring s ofs len) i) = (get s (ofs + i)%Z)).

Axiom concat_first :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length s1))%Z ->
  ((get (concat s1 s2) i) = (get s1 i)).

Axiom concat_second :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  forall (i:Numbers.BinNums.Z),
  ((length s1) <= i)%Z /\ (i < ((length s1) + (length s2))%Z)%Z ->
  ((get (concat s1 s2) i) = (get s2 (i - (length s1))%Z)).

(* Why3 assumption *)
Definition eq_string (s1:Strings.String.string) (s2:Strings.String.string) :
    Prop :=
  ((length s1) = (length s2)) /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length s1))%Z ->
   ((get s1 i) = (get s2 i))).

Axiom extensionality :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  eq_string s1 s2 -> (s1 = s2).

Parameter make: Numbers.BinNums.Z -> char -> Strings.String.string.

Axiom make_length :
  forall (size:Numbers.BinNums.Z) (v:char), (0%Z <= size)%Z ->
  ((length (make size v)) = size).

Axiom make_contents :
  forall (size:Numbers.BinNums.Z) (v:char), (0%Z <= size)%Z ->
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < size)%Z ->
  ((get (make size v) i) = v).

Axiom int63 : Type.
Parameter int63_WhyType : WhyType int63.
Existing Instance int63_WhyType.

Parameter int63'int: int63 -> Numbers.BinNums.Z.

Axiom int63'axiom :
  forall (i:int63),
  ((-4611686018427387904%Z)%Z <= (int63'int i))%Z /\
  ((int63'int i) <= 4611686018427387903%Z)%Z.

(* Why3 assumption *)
Definition int63'eq (a:int63) (b:int63) : Prop :=
  ((int63'int a) = (int63'int b)).

Axiom int63'inj : forall (a:int63) (b:int63), int63'eq a b -> (a = b).

(* Why3 assumption *)
Definition in_bounds (n:Numbers.BinNums.Z) : Prop :=
  ((-4611686018427387904%Z)%Z <= n)%Z /\ (n <= 4611686018427387903%Z)%Z.

Axiom to_int_in_bounds : forall (n:int63), in_bounds (int63'int n).

Axiom extensionality1 :
  forall (x:int63) (y:int63), ((int63'int x) = (int63'int y)) -> (x = y).

Parameter max_int: int63.

Axiom max_int'def : ((int63'int max_int) = 4611686018427387903%Z).

Parameter min_int: int63.

Axiom min_int'def : ((int63'int min_int) = (-4611686018427387904%Z)%Z).

(* Why3 assumption *)
Definition dataset (a:Type) := a.

(* Why3 assumption *)
Definition vsymb := Numbers.BinNums.Z.

(* Why3 assumption *)
Definition fsymb := Strings.String.string.

(* Why3 assumption *)
Definition psymb := Strings.String.string.

(* Why3 assumption *)
Inductive pvalue :=
  | Eq : Reals.Rdefinitions.R -> pvalue
  | Leq : Reals.Rdefinitions.R -> pvalue.
Axiom pvalue_WhyType : WhyType pvalue.
Existing Instance pvalue_WhyType.

(* Why3 assumption *)
Definition parameter := Strings.String.string.

(* Why3 assumption *)
Inductive real_number :=
  | Param : Strings.String.string -> real_number
  | Const : Reals.Rdefinitions.R -> real_number.
Axiom real_number_WhyType : WhyType real_number.
Existing Instance real_number_WhyType.

(* Why3 assumption *)
Inductive population :=
  | NormalD : real_number -> real_number -> population
  | BernoulliD : real_number -> population
  | CategoricalD : Init.Datatypes.list real_number -> population
  | UnknownD : Strings.String.string -> population.
Axiom population_WhyType : WhyType population.
Existing Instance population_WhyType.

Parameter ppl: forall {a:Type} {a_WT:WhyType a}, a -> population.

(* Why3 assumption *)
Inductive real_term :=
  | Real : real_number -> real_term.
Axiom real_term_WhyType : WhyType real_term.
Existing Instance real_term_WhyType.

(* Why3 assumption *)
Inductive term :=
  | RealT : real_term -> term
  | PopulationT : population -> term.
Axiom term_WhyType : WhyType term.
Existing Instance term_WhyType.

Parameter mean: population -> real_term.

Parameter var: population -> real_term.

Parameter med: population -> real_term.

(* Why3 assumption *)
Definition const_term (r:Reals.Rdefinitions.R) : real_term := Real (Const r).

Axiom Refl : True.

Axiom Trans :
  forall (x:Strings.String.string) (y:Strings.String.string)
    (z:Strings.String.string),
  (x = y) -> (y = z) -> (x = z).

Axiom Symm :
  forall (x:Strings.String.string) (y:Strings.String.string), (x = y) ->
  (y = x).

(* Why3 assumption *)
Definition eq_real_number (r1:real_number) (r2:real_number) : Prop :=
  match (r1, r2) with
  | (Param s, Param t) => (s = t)
  | (Const s, Const t) => (s = t)
  | _ => False
  end.

Axiom Refl1 : forall (x:real_number), eq_real_number x x.

Axiom Trans1 :
  forall (x:real_number) (y:real_number) (z:real_number),
  eq_real_number x y -> eq_real_number y z -> eq_real_number x z.

Axiom Symm1 :
  forall (x:real_number) (y:real_number), eq_real_number x y ->
  eq_real_number y x.

Parameter eq_real_number_list:
  Init.Datatypes.list real_number -> Init.Datatypes.list real_number -> Prop.

Axiom eq_real_number_list'def :
  forall (rs1:Init.Datatypes.list real_number)
    (rs2:Init.Datatypes.list real_number),
  match (rs1, rs2) with
  | (Init.Datatypes.cons h1 t1, Init.Datatypes.cons h2 t2) =>
      eq_real_number_list rs1 rs2 <->
      eq_real_number h1 h2 /\ eq_real_number_list t1 t2
  | (Init.Datatypes.nil, Init.Datatypes.nil) => eq_real_number_list rs1 rs2
  | _ => ~ eq_real_number_list rs1 rs2
  end.

Axiom Refl2 :
  forall (x:Init.Datatypes.list real_number), eq_real_number_list x x.

Axiom Trans2 :
  forall (x:Init.Datatypes.list real_number)
    (y:Init.Datatypes.list real_number) (z:Init.Datatypes.list real_number),
  eq_real_number_list x y -> eq_real_number_list y z ->
  eq_real_number_list x z.

Axiom Symm2 :
  forall (x:Init.Datatypes.list real_number)
    (y:Init.Datatypes.list real_number),
  eq_real_number_list x y -> eq_real_number_list y x.

(* Why3 assumption *)
Definition eq_population (p1:population) (p2:population) : Prop :=
  match (p1, p2) with
  | (NormalD s1 s2, NormalD t1 t2) =>
      eq_real_number s1 t1 /\ eq_real_number s2 t2
  | (BernoulliD s, BernoulliD t) => eq_real_number s t
  | (UnknownD i, UnknownD j) => (i = j)
  | (CategoricalD pp, CategoricalD qq) => eq_real_number_list pp qq
  | _ => False
  end.

Axiom Refl3 : forall (x:population), eq_population x x.

Axiom Trans3 :
  forall (x:population) (y:population) (z:population), eq_population x y ->
  eq_population y z -> eq_population x z.

Axiom Symm3 :
  forall (x:population) (y:population), eq_population x y ->
  eq_population y x.

Parameter eq_real_term: real_term -> real_term -> Prop.

Axiom Refl4 : forall (x:real_term), eq_real_term x x.

Axiom Trans4 :
  forall (x:real_term) (y:real_term) (z:real_term), eq_real_term x y ->
  eq_real_term y z -> eq_real_term x z.

Axiom Symm4 :
  forall (x:real_term) (y:real_term), eq_real_term x y -> eq_real_term y x.

Axiom eq_real_term_refl : forall (rt1:real_term), eq_real_term rt1 rt1.

Axiom eq_real_term_sym :
  forall (rt1:real_term) (rt2:real_term),
  eq_real_term rt1 rt2 <-> eq_real_term rt2 rt1.

Axiom eq_real_term_trans :
  forall (rt1:real_term) (rt2:real_term) (rt3:real_term),
  eq_real_term rt1 rt2 /\ eq_real_term rt2 rt3 -> eq_real_term rt1 rt3.

Axiom eq_real_term_real :
  forall (r1:real_number) (r2:real_number),
  eq_real_term (Real r1) (Real r2) <-> eq_real_number r1 r2.

Axiom eq_real_term_mean :
  forall (p1:population) (p2:population),
  eq_real_term (mean p1) (mean p2) <-> eq_population p1 p2.

Axiom eq_real_term_var :
  forall (p1:population) (p2:population),
  eq_real_term (var p1) (var p2) <-> eq_population p1 p2.

Axiom eq_real_term_med :
  forall (p1:population) (p2:population),
  eq_real_term (med p1) (med p2) <-> eq_population p1 p2.

(* Why3 assumption *)
Definition eq_term (t1:term) (t2:term) : Prop :=
  match (t1, t2) with
  | (RealT t11, RealT t21) => eq_real_term t11 t21
  | (PopulationT p1, PopulationT p2) => eq_population p1 p2
  | _ => False
  end.

Axiom Refl5 : forall (x:term), eq_term x x.

Axiom Trans5 :
  forall (x:term) (y:term) (z:term), eq_term x y -> eq_term y z ->
  eq_term x z.

Axiom Symm5 : forall (x:term) (y:term), eq_term x y -> eq_term y x.

Parameter eq_term_list:
  Init.Datatypes.list term -> Init.Datatypes.list term -> Prop.

Axiom eq_term_list'def :
  forall (t1:Init.Datatypes.list term) (t2:Init.Datatypes.list term),
  match (t1, t2) with
  | (Init.Datatypes.cons hd1 tl1, Init.Datatypes.cons hd2 tl2) =>
      (eq_term hd1 hd2 -> eq_term_list t1 t2 <-> eq_term_list tl1 tl2) /\
      (~ eq_term hd1 hd2 -> ~ eq_term_list t1 t2)
  | (Init.Datatypes.cons _ _, Init.Datatypes.nil)|(Init.Datatypes.nil,
                                                   Init.Datatypes.cons _ _) =>
      ~ eq_term_list t1 t2
  | (Init.Datatypes.nil, Init.Datatypes.nil) => eq_term_list t1 t2
  end.

Axiom Refl6 : forall (x:Init.Datatypes.list term), eq_term_list x x.

Axiom Trans6 :
  forall (x:Init.Datatypes.list term) (y:Init.Datatypes.list term)
    (z:Init.Datatypes.list term),
  eq_term_list x y -> eq_term_list y z -> eq_term_list x z.

Axiom Symm6 :
  forall (x:Init.Datatypes.list term) (y:Init.Datatypes.list term),
  eq_term_list x y -> eq_term_list y x.

(* Why3 assumption *)
Inductive atomic_formula :=
  | Pred : Strings.String.string -> Init.Datatypes.list term ->
      atomic_formula.
Axiom atomic_formula_WhyType : WhyType atomic_formula.
Existing Instance atomic_formula_WhyType.

(* Why3 assumption *)
Inductive formula :=
  | Atom : atomic_formula -> formula
  | Not : formula -> formula
  | Conj : formula -> formula -> formula
  | Disj : formula -> formula -> formula
  | Impl : formula -> formula -> formula
  | Equiv : formula -> formula -> formula
  | Possible : formula -> formula
  | Know : formula -> formula
  | StatTau : pvalue -> formula -> formula
  | StatB : pvalue -> formula -> formula.
Axiom formula_WhyType : WhyType formula.
Existing Instance formula_WhyType.

(* Why3 assumption *)
Definition eq_atom (a1:atomic_formula) (a2:atomic_formula) : Prop :=
  match (a1, a2) with
  | (Pred p1 tl1, Pred p2 tl2) => (p1 = p2) /\ eq_term_list tl1 tl2
  end.

Axiom Refl7 : forall (x:atomic_formula), eq_atom x x.

Axiom Trans7 :
  forall (x:atomic_formula) (y:atomic_formula) (z:atomic_formula),
  eq_atom x y -> eq_atom y z -> eq_atom x z.

Axiom Symm7 :
  forall (x:atomic_formula) (y:atomic_formula), eq_atom x y -> eq_atom y x.

Axiom eq_atom_neq_pred :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  forall (tl1:Init.Datatypes.list term) (tl2:Init.Datatypes.list term),
  ~ (s1 = s2) -> ~ eq_atom (Pred s1 tl1) (Pred s2 tl2).

Axiom eq_atom_neq_tl :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  forall (tl1:Init.Datatypes.list term) (tl2:Init.Datatypes.list term),
  ~ eq_term_list tl1 tl2 -> ~ eq_atom (Pred s1 tl1) (Pred s2 tl2).

Parameter eq_hypothesis: formula -> formula -> Prop.

Axiom eq_hypothesis'def :
  forall (h1:formula) (h2:formula),
  match (h1, h2) with
  | (Disj h11 h12, Disj h21 h22) =>
      eq_hypothesis h1 h2 <-> eq_hypothesis h11 h21 /\ eq_hypothesis h12 h22
  | (Conj h11 h12, Conj h21 h22) =>
      eq_hypothesis h1 h2 <-> eq_hypothesis h11 h21 /\ eq_hypothesis h12 h22
  | (Atom ah1, Atom ah2) => eq_hypothesis h1 h2 <-> eq_atom ah1 ah2
  | (Not h11, Not h21) => eq_hypothesis h1 h2 <-> eq_hypothesis h11 h21
  | _ => ~ eq_hypothesis h1 h2
  end.

(* Why3 assumption *)
Fixpoint length_fml (fml:formula) {struct fml}: Numbers.BinNums.Z :=
  match fml with
  | Not fml1 => (1%Z + (length_fml fml1))%Z
  | Disj fml1 fml2 => ((1%Z + (length_fml fml1))%Z + (length_fml fml2))%Z
  | Conj fml1 fml2 => ((1%Z + (length_fml fml1))%Z + (length_fml fml2))%Z
  | Impl fml1 fml2 => ((1%Z + (length_fml fml1))%Z + (length_fml fml2))%Z
  | Equiv fml1 fml2 => ((1%Z + (length_fml fml1))%Z + (length_fml fml2))%Z
  | Know fml1 => (1%Z + (length_fml fml1))%Z
  | StatTau _ fml1 => (1%Z + (length_fml fml1))%Z
  | StatB _ fml1 => (1%Z + (length_fml fml1))%Z
  | _ => 1%Z
  end.

(* Why3 assumption *)
Definition store_elm := (Strings.String.string* formula* pvalue)%type.

(* Why3 assumption *)
Definition store :=
  Init.Datatypes.list (Strings.String.string* formula* pvalue)%type.

(* Why3 assumption *)
Inductive alternative :=
  | Two : alternative
  | Up : alternative
  | Low : alternative.
Axiom alternative_WhyType : WhyType alternative.
Existing Instance alternative_WhyType.

(* Why3 assumption *)
Definition disjpvs (pv1:pvalue) (pv2:pvalue) : pvalue :=
  match (pv1, pv2) with
  | (Eq r1, Eq r2)|((Eq r1, Leq r2)|((Leq r1, Eq r2)|(Leq r1, Leq r2))) =>
      Leq (r1 + r2)%R
  end.

Parameter conjpvs: pvalue -> pvalue -> pvalue.

Axiom conjpvs'def :
  forall (pv1:pvalue) (pv2:pvalue),
  match (pv1, pv2) with
  | (Eq r1, Eq r2)|((Eq r1, Leq r2)|((Leq r1, Eq r2)|(Leq r1, Leq r2))) =>
      ((r1 < r2)%R -> ((conjpvs pv1 pv2) = (Leq r1))) /\
      (~ (r1 < r2)%R -> ((conjpvs pv1 pv2) = (Leq r2)))
  end.

Parameter mem_fml_in_store:
  formula ->
  Init.Datatypes.list (Strings.String.string* formula* pvalue)%type ->
  Init.Datatypes.bool.

Axiom mem_fml_in_store'def :
  forall (h:formula)
    (st:Init.Datatypes.list (Strings.String.string* formula* pvalue)%type),
  (match st with
   | Init.Datatypes.cons (_, h', _) st' =>
       eq_hypothesis h h' \/ ((mem_fml_in_store h st') = Init.Datatypes.true)
   | Init.Datatypes.nil => False
   end -> ((mem_fml_in_store h st) = Init.Datatypes.true)) /\
  (~ match st with
     | Init.Datatypes.cons (_, h', _) st' =>
         eq_hypothesis h h' \/
         ((mem_fml_in_store h st') = Init.Datatypes.true)
     | Init.Datatypes.nil => False
     end ->
   ((mem_fml_in_store h st) = Init.Datatypes.false)).

Parameter consistent_fml_store:
  formula ->
  Init.Datatypes.list (Strings.String.string* formula* pvalue)%type ->
  Init.Datatypes.bool.

Axiom consistent_fml_store'def :
  forall (h:formula)
    (st:Init.Datatypes.list (Strings.String.string* formula* pvalue)%type),
  (((mem_fml_in_store h st) = Init.Datatypes.true) \/
   match h with
   | Disj h1 h2 =>
       ((consistent_fml_store h1 st) = Init.Datatypes.true) /\
       ((consistent_fml_store h2 st) = Init.Datatypes.true)
   | Conj h1 h2 =>
       ((consistent_fml_store h1 st) = Init.Datatypes.true) /\
       ((consistent_fml_store h2 st) = Init.Datatypes.true)
   | _ => False
   end -> ((consistent_fml_store h st) = Init.Datatypes.true)) /\
  (~ (((mem_fml_in_store h st) = Init.Datatypes.true) \/
      match h with
      | Disj h1 h2 =>
          ((consistent_fml_store h1 st) = Init.Datatypes.true) /\
          ((consistent_fml_store h2 st) = Init.Datatypes.true)
      | Conj h1 h2 =>
          ((consistent_fml_store h1 st) = Init.Datatypes.true) /\
          ((consistent_fml_store h2 st) = Init.Datatypes.true)
      | _ => False
      end) ->
   ((consistent_fml_store h st) = Init.Datatypes.false)).

Parameter get_pv:
  formula ->
  Init.Datatypes.list (Strings.String.string* formula* pvalue)%type ->
  pvalue.

Axiom get_pv'def :
  forall (h:formula)
    (st:Init.Datatypes.list (Strings.String.string* formula* pvalue)%type),
  match st with
  | Init.Datatypes.cons (_, h', pv) st' =>
      (eq_hypothesis h' h ->
       (((mem_fml_in_store h st') = Init.Datatypes.true) ->
        ((get_pv h st) = (disjpvs (get_pv h st') pv))) /\
       (~ ((mem_fml_in_store h st') = Init.Datatypes.true) ->
        ((get_pv h st) = pv))) /\
      (~ eq_hypothesis h' h -> ((get_pv h st) = (get_pv h st')))
  | Init.Datatypes.nil => ((get_pv h st) = (Eq 0%R))
  end.

Parameter compose_pvs:
  formula ->
  Init.Datatypes.list (Strings.String.string* formula* pvalue)%type ->
  pvalue.

Axiom compose_pvs'def :
  forall (h:formula)
    (st:Init.Datatypes.list (Strings.String.string* formula* pvalue)%type),
  (((mem_fml_in_store h st) = Init.Datatypes.true) ->
   ((compose_pvs h st) = (get_pv h st))) /\
  (~ ((mem_fml_in_store h st) = Init.Datatypes.true) ->
   ((compose_pvs h st) =
    match h with
    | Atom _ => get_pv h st
    | Not _ => Eq (-1000%R)%R
    | Disj h1 h2 => disjpvs (compose_pvs h1 st) (compose_pvs h2 st)
    | Conj h1 h2 => conjpvs (compose_pvs h1 st) (compose_pvs h2 st)
    | (Impl _ _)|((Equiv _ _)|((Know _)|((StatTau _ _)|(StatB _ _)))) =>
        Eq (-1000%R)%R
    | _ => Eq 0%R
    end)).

Axiom get_pv_recursive1 :
  forall (h1:formula)
    (st:Init.Datatypes.list (Strings.String.string* formula* pvalue)%type)
    (f:Strings.String.string) (p:pvalue),
  eq_hypothesis h1 h1 /\ ((mem_fml_in_store h1 st) = Init.Datatypes.true) ->
  ((get_pv h1 (Init.Datatypes.cons (f, h1, p) st)) =
   (disjpvs p (get_pv h1 st))).

Axiom get_pv_recursive2 :
  forall (h1:atomic_formula) (h2:atomic_formula)
    (st:Init.Datatypes.list (Strings.String.string* formula* pvalue)%type)
    (f:Strings.String.string) (p:pvalue),
  ~ eq_atom h1 h2 ->
  ((get_pv (Atom h1) (Init.Datatypes.cons (f, Atom h2, p) st)) =
   (get_pv (Atom h1) st)).

Axiom compose_pvs_atom :
  forall (afml:atomic_formula)
    (st:Init.Datatypes.list (Strings.String.string* formula* pvalue)%type),
  ((compose_pvs (Atom afml) st) = (get_pv (Atom afml) st)).

Axiom compose_pvs_disj3 :
  forall (h:formula) (ah:atomic_formula)
    (st:Init.Datatypes.list (Strings.String.string* formula* pvalue)%type),
  ~ ((mem_fml_in_store (Disj (Atom ah) h) st) = Init.Datatypes.true) ->
  ((compose_pvs (Disj (Atom ah) h) st) =
   (disjpvs (get_pv (Atom ah) st) (compose_pvs h st))).

Axiom compose_pvs_disj4 :
  forall (h:formula) (ah:atomic_formula)
    (st:Init.Datatypes.list (Strings.String.string* formula* pvalue)%type),
  ~ ((mem_fml_in_store (Disj h (Atom ah)) st) = Init.Datatypes.true) ->
  ((compose_pvs (Disj h (Atom ah)) st) =
   (disjpvs (compose_pvs h st) (get_pv (Atom ah) st))).

Axiom compose_pvs_disj1 :
  forall (h1:formula) (h2:formula)
    (st:Init.Datatypes.list (Strings.String.string* formula* pvalue)%type),
  ~ ((mem_fml_in_store (Disj h1 h2) st) = Init.Datatypes.true) ->
  ((compose_pvs (Disj h1 h2) st) =
   (disjpvs (compose_pvs h1 st) (compose_pvs h2 st))).

Axiom compose_pvs_disj2 :
  forall (h1:formula) (h2:formula)
    (st:Init.Datatypes.list (Strings.String.string* formula* pvalue)%type)
    (p1:pvalue) (p2:pvalue),
  ~ ((mem_fml_in_store (Disj h1 h2) st) = Init.Datatypes.true) ->
  ((compose_pvs (Disj h1 h2) st) = (disjpvs p1 p2)) <->
  (exists r1:pvalue, exists r2:pvalue,
   ((compose_pvs h1 st) = r1) /\
   ((compose_pvs h2 st) = r2) /\
   ((compose_pvs (Disj h1 h2) st) = (disjpvs p1 p2))).

Axiom compose_pvs_disj5 :
  forall (h1:formula) (h2:formula) (h3:formula) (h4:formula)
    (st:Init.Datatypes.list (Strings.String.string* formula* pvalue)%type),
  ((mem_fml_in_store (Disj h1 h2) st) = Init.Datatypes.true) /\
  ((mem_fml_in_store (Disj h3 h4) st) = Init.Datatypes.true) /\
  ~ ((mem_fml_in_store (Disj (Disj h1 h2) (Disj h3 h4)) st) =
     Init.Datatypes.true) ->
  ((compose_pvs (Disj (Disj h1 h2) (Disj h3 h4)) st) =
   (disjpvs (get_pv (Disj h1 h2) st) (get_pv (Disj h3 h4) st))).

Axiom compose_pvs_conj :
  forall (h1:formula) (h2:formula)
    (st:Init.Datatypes.list (Strings.String.string* formula* pvalue)%type),
  ~ ((mem_fml_in_store (Conj h1 h2) st) = Init.Datatypes.true) ->
  ((compose_pvs (Conj h1 h2) st) =
   (conjpvs (compose_pvs h1 st) (compose_pvs h2 st))).

(* Why3 assumption *)
Definition stat_believe (pv:pvalue) (h:formula)
    (st:Init.Datatypes.list (Strings.String.string* formula* pvalue)%type) :
    Prop :=
  match pv with
  | Eq _ => (pv = (compose_pvs h st))
  | Leq p => match compose_pvs h st with
             | (Eq q)|(Leq q) => (q <= p)%R
             end
  end.

Axiom stat_believe_mem :
  forall (h:formula)
    (st:Init.Datatypes.list (Strings.String.string* formula* pvalue)%type),
  ((mem_fml_in_store h st) = Init.Datatypes.true) ->
  stat_believe (get_pv h st) h st.

Axiom compose_pvs_implies_stat_believe :
  forall (h:formula)
    (st:Init.Datatypes.list (Strings.String.string* formula* pvalue)%type)
    (p:pvalue),
  (p = (compose_pvs h st)) -> stat_believe p h st.

Axiom stat_believe_disj :
  forall (pv1:pvalue) (pv2:pvalue) (h1:formula) (h2:formula)
    (st:Init.Datatypes.list (Strings.String.string* formula* pvalue)%type),
  stat_believe pv1 h1 st /\
  stat_believe pv2 h2 st /\
  ~ ((mem_fml_in_store (Disj h1 h2) st) = Init.Datatypes.true) ->
  stat_believe (disjpvs pv1 pv2) (Disj h1 h2) st.

Axiom stat_believe_conj :
  forall (pv1:pvalue) (pv2:pvalue) (h1:formula) (h2:formula)
    (st:Init.Datatypes.list (Strings.String.string* formula* pvalue)%type),
  stat_believe pv1 h1 st /\
  stat_believe pv2 h2 st /\
  ~ ((mem_fml_in_store (Conj h1 h2) st) = Init.Datatypes.true) ->
  stat_believe (conjpvs pv1 pv2) (Conj h1 h2) st.

Axiom stat_believe_eq_implies_leq :
  forall (p:Reals.Rdefinitions.R) (h:formula)
    (st:Init.Datatypes.list (Strings.String.string* formula* pvalue)%type),
  stat_believe (Eq p) h st -> stat_believe (Leq p) h st.

(* Why3 assumption *)
Definition interpretation := real_term -> Reals.Rdefinitions.R.

Axiom interp_const :
  forall (r:Reals.Rdefinitions.R) (i:real_term -> Reals.Rdefinitions.R),
  ((i (Real (Const r))) = r).

(* Why3 assumption *)
Inductive world :=
  | World : Init.Datatypes.list (Strings.String.string* formula* pvalue)%type ->
      (real_term -> Reals.Rdefinitions.R) -> world.
Axiom world_WhyType : WhyType world.
Existing Instance world_WhyType.

Parameter infix_breq: world -> formula -> Prop.

Axiom interpretation_afml_invariance :
  forall (afml:atomic_formula)
    (st:Init.Datatypes.list (Strings.String.string* formula* pvalue)%type)
    (st':Init.Datatypes.list (Strings.String.string* formula* pvalue)%type)
    (i:real_term -> Reals.Rdefinitions.R),
  infix_breq (World st i) (Atom afml) -> infix_breq (World st' i) (Atom afml).

Axiom interpretation_neg :
  forall (w:world), forall (h1:formula),
  infix_breq w (Not h1) <-> ~ infix_breq w h1.

Axiom interpretation_disj :
  forall (w:world), forall (h1:formula), forall (h2:formula),
  infix_breq w (Disj h1 h2) <-> infix_breq w h1 \/ infix_breq w h2.

Axiom interpretation_conj :
  forall (w:world), forall (h1:formula), forall (h2:formula),
  infix_breq w (Conj h1 h2) <-> infix_breq w h1 /\ infix_breq w h2.

Axiom interpretation_impl :
  forall (w:world), forall (h1:formula), forall (h2:formula),
  infix_breq w (Impl h1 h2) <-> (infix_breq w h1 -> infix_breq w h2).

Axiom interpretation_equiv :
  forall (w:world), forall (h1:formula), forall (h2:formula),
  infix_breq w (Equiv h1 h2) <-> infix_breq w (Impl h1 h2).

Axiom tautology_double_negation :
  forall (w:world), forall (h:formula), infix_breq w (Equiv h (Not (Not h))).

Axiom tautology_excluded_middle :
  forall (w:world), forall (h:formula), infix_breq w (Disj h (Not h)).

Axiom tautology_implication :
  forall (w:world), forall (h1:formula), forall (h2:formula),
  infix_breq w (Equiv (Impl h1 h2) (Disj (Not h1) h2)).

Axiom tautology_assoc_c :
  forall (w:world), forall (h1:formula), forall (h2:formula),
  forall (h3:formula),
  infix_breq w (Equiv (Conj h1 (Conj h2 h3)) (Conj (Conj h1 h2) h3)).

Axiom tautology_assoc_d :
  forall (w:world), forall (h1:formula), forall (h2:formula),
  forall (h3:formula),
  infix_breq w (Equiv (Disj h1 (Disj h2 h3)) (Disj (Disj h1 h2) h3)).

Axiom tautology_commut_c :
  forall (w:world), forall (h1:formula), forall (h2:formula),
  infix_breq w (Equiv (Conj h1 h2) (Conj h2 h1)).

Axiom tautology_commut_d :
  forall (w:world), forall (h1:formula), forall (h2:formula),
  infix_breq w (Equiv (Disj h1 h2) (Disj h2 h1)).

Axiom tautology_distr_cd :
  forall (w:world), forall (h1:formula), forall (h2:formula),
  forall (h3:formula),
  infix_breq w
  (Equiv (Conj h1 (Disj h2 h3)) (Disj (Conj h1 h2) (Conj h1 h3))).

Axiom tautology_distr_dc :
  forall (w:world), forall (h1:formula), forall (h2:formula),
  forall (h3:formula),
  infix_breq w
  (Equiv (Disj h1 (Conj h2 h3)) (Conj (Disj h1 h2) (Disj h1 h3))).

Axiom tautology_de_Morgan_nc :
  forall (w:world), forall (h1:formula), forall (h2:formula),
  infix_breq w (Equiv (Not (Conj h1 h2)) (Disj (Not h1) (Not h2))).

Axiom tautology_de_Morgan_nd :
  forall (w:world), forall (h1:formula), forall (h2:formula),
  infix_breq w (Equiv (Not (Disj h1 h2)) (Conj (Not h1) (Not h2))).

Axiom tautology_transposition :
  forall (w:world), forall (h1:formula), forall (h2:formula),
  infix_breq w (Equiv (Impl h1 h2) (Impl (Not h2) (Not h1))).

Axiom tautology_exportation :
  forall (w:world), forall (h1:formula), forall (h2:formula),
  forall (h3:formula),
  infix_breq w (Equiv (Impl (Conj h1 h2) h3) (Impl h1 (Impl h2 h3))).

Axiom tautology_absorption_cd :
  forall (w:world), forall (h1:formula), forall (h2:formula),
  infix_breq w (Equiv (Conj h1 (Disj h1 h2)) h1).

Axiom tautology_absorption_dc :
  forall (w:world), forall (h1:formula), forall (h2:formula),
  infix_breq w (Equiv (Disj h1 (Conj h1 h2)) h1).

Axiom ax_p_interpretation :
  forall (st:
          Init.Datatypes.list (Strings.String.string* formula* pvalue)%type)
    (i:real_term -> Reals.Rdefinitions.R) (h:formula),
  infix_breq (World st i) (Possible h) <->
  (exists j:real_term -> Reals.Rdefinitions.R, infix_breq (World st j) h).

Axiom ax_k_interpretation :
  forall (st:
          Init.Datatypes.list (Strings.String.string* formula* pvalue)%type)
    (i:real_term -> Reals.Rdefinitions.R) (h:formula),
  infix_breq (World st i) (Know h) <->
  (forall (j:real_term -> Reals.Rdefinitions.R), infix_breq (World st j) h).

Axiom rule_N :
  forall (h:formula), (forall (w1:world), infix_breq w1 h) ->
  forall (w2:world), infix_breq w2 (Know h).

Axiom ax_K :
  forall (w:world), forall (h1:formula), forall (h2:formula),
  infix_breq w (Know (Impl h1 h2)) -> infix_breq w (Know h1) ->
  infix_breq w (Know h2).

Axiom ax_T :
  forall (w:world), forall (h:formula), infix_breq w (Know h) ->
  infix_breq w h.

Axiom ax_5 :
  forall (w:world), forall (h:formula), infix_breq w (Possible h) ->
  infix_breq w (Know (Possible h)).

Axiom lem_not_possible :
  forall (st:
          Init.Datatypes.list (Strings.String.string* formula* pvalue)%type)
    (i:real_term -> Reals.Rdefinitions.R) (h:formula),
  infix_breq (World st i) (Not (Possible h)) <->
  (forall (j:real_term -> Reals.Rdefinitions.R),
   infix_breq (World st j) (Not h)).

Axiom lem_know_not :
  forall (st:
          Init.Datatypes.list (Strings.String.string* formula* pvalue)%type)
    (i:real_term -> Reals.Rdefinitions.R) (h:formula),
  infix_breq (World st i) (Know (Not h)) <->
  (forall (j:real_term -> Reals.Rdefinitions.R),
   infix_breq (World st j) (Not h)).

Axiom lem_not_know :
  forall (st:
          Init.Datatypes.list (Strings.String.string* formula* pvalue)%type)
    (i:real_term -> Reals.Rdefinitions.R) (h:formula),
  infix_breq (World st i) (Not (Know h)) <->
  (exists j:real_term -> Reals.Rdefinitions.R,
   infix_breq (World st j) (Not h)).

Axiom lem_possible_not :
  forall (st:
          Init.Datatypes.list (Strings.String.string* formula* pvalue)%type)
    (i:real_term -> Reals.Rdefinitions.R) (h:formula),
  infix_breq (World st i) (Possible (Not h)) <->
  (exists j:real_term -> Reals.Rdefinitions.R,
   infix_breq (World st j) (Not h)).

Axiom ax_duality_p_k' :
  forall (st:
          Init.Datatypes.list (Strings.String.string* formula* pvalue)%type)
    (i:real_term -> Reals.Rdefinitions.R) (h:formula),
  infix_breq (World st i) (Not (Possible h)) <->
  infix_breq (World st i) (Know (Not h)).

Axiom ax_duality_k_p' :
  forall (st:
          Init.Datatypes.list (Strings.String.string* formula* pvalue)%type)
    (i:real_term -> Reals.Rdefinitions.R) (h:formula),
  infix_breq (World st i) (Not (Know h)) <->
  infix_breq (World st i) (Possible (Not h)).

Axiom ax_duality_p_k'' :
  forall (w:world), forall (h:formula),
  (infix_breq w (Not (Possible h)) <->
   match w with
   | World st i => infix_breq (World st i) (Not (Possible h))
   end) /\
  (match w with
   | World st i => infix_breq (World st i) (Not (Possible h))
   end <->
   match w with
   | World st i => infix_breq (World st i) (Know (Not h))
   end) /\
  (match w with
   | World st i => infix_breq (World st i) (Know (Not h))
   end <-> infix_breq w (Know (Not h))) /\
  (infix_breq w (Not (Possible h)) <-> infix_breq w (Know (Not h))).

Axiom ax_duality_k_p'' :
  forall (w:world), forall (h:formula),
  (infix_breq w (Not (Know h)) <->
   match w with
   | World st i => infix_breq (World st i) (Not (Know h))
   end) /\
  (match w with
   | World st i => infix_breq (World st i) (Not (Know h))
   end <->
   match w with
   | World st i => infix_breq (World st i) (Possible (Not h))
   end) /\
  (match w with
   | World st i => infix_breq (World st i) (Possible (Not h))
   end <-> infix_breq w (Possible (Not h))) /\
  (infix_breq w (Not (Know h)) <-> infix_breq w (Possible (Not h))).

Axiom ax_duality_p_k :
  forall (w:world), forall (h:formula),
  infix_breq w (Not (Possible h)) <-> infix_breq w (Know (Not h)).

Axiom ax_duality_k_p :
  forall (w:world), forall (h:formula),
  infix_breq w (Not (Know h)) <-> infix_breq w (Possible (Not h)).

Axiom ax_B :
  forall (w:world), forall (h:formula), infix_breq w h ->
  infix_breq w (Know (Possible h)).

Axiom ax_T_dual :
  forall (w:world), forall (h:formula), infix_breq w h ->
  infix_breq w (Possible h).

Axiom lem_duality_1 :
  forall (w:world), forall (h:formula),
  infix_breq w (Not (Possible (Know h))) <->
  infix_breq w (Know (Not (Know h))).

Axiom lem_duality_2l :
  forall (w:world), forall (h:formula),
  infix_breq w (Know (Impl (Not (Know h)) (Possible (Not h)))).

Axiom lem_duality_2r :
  forall (w:world), forall (h:formula),
  infix_breq w (Know (Impl (Possible (Not h)) (Not (Know h)))).

Axiom lem_duality_3l :
  forall (w:world), forall (h:formula),
  infix_breq w (Know (Impl (Not (Know h)) (Possible (Not h)))) ->
  infix_breq w (Know (Not (Know h))) ->
  infix_breq w (Know (Possible (Not h))).

Axiom lem_duality_3r :
  forall (w:world), forall (h:formula),
  infix_breq w (Know (Impl (Possible (Not h)) (Not (Know h)))) ->
  infix_breq w (Know (Possible (Not h))) ->
  infix_breq w (Know (Not (Know h))).

Axiom lem_duality_4 :
  forall (w:world), forall (h:formula),
  infix_breq w (Know (Not (Know h))) <->
  infix_breq w (Know (Possible (Not h))).

Axiom ax_5_not :
  forall (w:world), forall (h:formula), infix_breq w (Possible (Not h)) ->
  infix_breq w (Know (Possible (Not h))).

Axiom ax_5_not_dual1 :
  forall (w:world), forall (h:formula), infix_breq w (Not (Know h)) ->
  infix_breq w (Know (Not (Know h))).

Axiom ax_5_not_dual2 :
  forall (w:world), forall (h:formula), infix_breq w (Not (Know h)) ->
  infix_breq w (Not (Possible (Know h))).

Axiom ax_5_dual :
  forall (w:world), forall (h:formula), infix_breq w (Possible (Know h)) ->
  infix_breq w (Know h).

Axiom ax_B_box :
  forall (w:world), forall (h:formula), infix_breq w (Possible (Know h)) ->
  infix_breq w (Know (Possible (Know h))).

Axiom ax_box_5_box :
  forall (w:world), forall (h:formula),
  infix_breq w (Know (Impl (Possible (Know h)) (Know h))).

Axiom lem_dist_dbid :
  forall (w:world), forall (h:formula),
  infix_breq w (Know (Impl (Possible (Know h)) (Know h))) ->
  infix_breq w (Know (Possible (Know h))) -> infix_breq w (Know (Know h)).

Axiom lem_dbdibb :
  forall (w:world), forall (h:formula),
  infix_breq w (Impl (Know (Possible (Know h))) (Know (Know h))).

Axiom ax_4 :
  forall (w:world), forall (h:formula), infix_breq w (Know h) ->
  infix_breq w (Know (Know h)).

Axiom know_impl_l :
  forall (w:world), forall (h1:formula), forall (h2:formula),
  infix_breq w (Know (Impl h1 (Disj h1 h2))).

Axiom know_impl_r :
  forall (w:world), forall (h1:formula), forall (h2:formula),
  infix_breq w (Know (Impl h1 (Disj h2 h1))).

Axiom ax_K_disj_l :
  forall (w:world), forall (h1:formula), forall (h2:formula),
  infix_breq w (Know (Impl h1 (Disj h1 h2))) -> infix_breq w (Know h1) ->
  infix_breq w (Know (Disj h1 h2)).

Axiom know_disj_l :
  forall (w:world), forall (h1:formula), forall (h2:formula),
  infix_breq w (Know h1) -> infix_breq w (Know (Disj h1 h2)).

Axiom ax_K_disj_r :
  forall (w:world), forall (h1:formula), forall (h2:formula),
  infix_breq w (Know (Impl h1 (Disj h2 h1))) -> infix_breq w (Know h1) ->
  infix_breq w (Know (Disj h2 h1)).

Axiom know_disj_r :
  forall (w:world), forall (h1:formula), forall (h2:formula),
  infix_breq w (Know h1) -> infix_breq w (Know (Disj h2 h1)).

Axiom interpretation_stat_tau :
  forall (w:world), forall (pvs:pvalue), forall (h:formula),
  match w with
  | World st _ => infix_breq w (StatTau pvs h) <-> stat_believe pvs h st
  end.

Axiom ax_k_stat_tau :
  forall (w:world), forall (pvs:pvalue), forall (h:formula),
  infix_breq w (StatTau pvs h) <-> infix_breq w (Know (StatTau pvs h)).

Axiom ax_p_stat_tau :
  forall (w:world), forall (pvs:pvalue), forall (h:formula),
  infix_breq w (StatTau pvs h) <-> infix_breq w (Possible (StatTau pvs h)).

Axiom interpretation_statb :
  forall (w:world), forall (pvs:pvalue), forall (h:formula),
  infix_breq w (StatB pvs h) <-> infix_breq w (Know (Disj (StatTau pvs h) h)).

Axiom tau_implies_stat_believe :
  forall (w:world) (p:pvalue) (h:formula),
  match w with
  | World st _ => infix_breq w (StatTau p h) -> stat_believe p h st
  end.

Axiom BHT :
  forall (w:world), forall (h:formula), forall (pv:pvalue),
  infix_breq w (StatTau pv h) -> infix_breq w (StatB pv h).

Axiom lem_SB4_sub1 :
  forall (w:world), forall (h:formula), forall (pvs:pvalue),
  let kdh := Know (Disj (StatTau pvs h) h) in
  infix_breq w kdh -> infix_breq w (Know kdh).

Axiom lem_SB4_sub2 :
  forall (w:world), forall (h:formula), forall (pvs:pvalue),
  infix_breq w (StatB pvs h) ->
  infix_breq w (Know (Know (Disj (StatTau pvs h) h))).

Axiom lem_SB4_sub3 :
  forall (w:world), forall (h:formula), forall (pvs:pvalue),
  infix_breq w (Equiv (Know (Disj (StatTau pvs h) h)) (StatB pvs h)).

Axiom lem_SB4_sub4 :
  forall (w:world), forall (h:formula), forall (pvs:pvalue),
  infix_breq w (Know (Impl (Know (Disj (StatTau pvs h) h)) (StatB pvs h))).

Axiom lem_SB4_sub5 :
  forall (w:world), forall (h:formula), forall (pvs:pvalue),
  let kdh := Know (Disj (StatTau pvs h) h) in
  let sbh := StatB pvs h in
  infix_breq w (Know (Impl kdh sbh)) -> infix_breq w (Know kdh) ->
  infix_breq w (Know sbh).

Axiom SB4 :
  forall (w:world), forall (h:formula), forall (pvs:pvalue),
  let sbh := StatB pvs h in infix_breq w sbh -> infix_breq w (Know sbh).

Axiom lem_tau_implies_StatB :
  forall (w:world), forall (h:formula), forall (pvs:pvalue),
  match w with
  | World st _ =>
      match pvs with
      | Eq _ => (pvs = (compose_pvs h st)) -> infix_breq w (StatB pvs h)
      | Leq p =>
          match compose_pvs h st with
          | Eq q => (q <= p)%R -> infix_breq w (StatB pvs h)
          | Leq q => (q <= p)%R -> infix_breq w (StatB pvs h)
          end
      end
  end.

Axiom stat_believe_implies_StatB :
  forall (w:world), forall (h:formula), forall (pv:pvalue),
  match w with
  | World st _ => stat_believe pv h st -> infix_breq w (StatB pv h)
  end.

Axiom lem_tau_implies_StatB_disj :
  forall (w:world), forall (h1:formula) (h2:formula), forall (pvs:pvalue),
  match w with
  | World st _ =>
      let h12 := Disj h1 h2 in
      ((consistent_fml_store h1 st) = Init.Datatypes.true) /\
      ((consistent_fml_store h2 st) = Init.Datatypes.true) /\
      (pvs = (compose_pvs h12 st)) -> infix_breq w (StatB pvs h12)
  end.

Axiom lem_tau_implies_StatB_conj :
  forall (w:world), forall (h1:formula) (h2:formula), forall (pvs:pvalue),
  match w with
  | World st _ =>
      let h12 := Conj h1 h2 in
      ((consistent_fml_store h1 st) = Init.Datatypes.true) /\
      ((consistent_fml_store h2 st) = Init.Datatypes.true) /\
      (pvs = (compose_pvs h12 st)) -> infix_breq w (StatB pvs h12)
  end.

Axiom st_invariant :
  forall (st:
          Init.Datatypes.list (Strings.String.string* formula* pvalue)%type)
    (st':Init.Datatypes.list (Strings.String.string* formula* pvalue)%type)
    (i:real_term -> Reals.Rdefinitions.R)
    (j:real_term -> Reals.Rdefinitions.R) (afml:atomic_formula),
  let fmlA := Atom afml in
  infix_breq (World st i) (Possible fmlA) /\ infix_breq (World st j) fmlA ->
  infix_breq (World st' j) fmlA /\ infix_breq (World st' i) (Possible fmlA).

Axiom st_invariant' :
  forall (st:
          Init.Datatypes.list (Strings.String.string* formula* pvalue)%type)
    (st':Init.Datatypes.list (Strings.String.string* formula* pvalue)%type)
    (i:real_term -> Reals.Rdefinitions.R) (afml:atomic_formula),
  let fmlA := Atom afml in
  infix_breq (World st i) (Possible fmlA) ->
  infix_breq (World st' i) (Possible fmlA).

Parameter rliteral1: Strings.String.string.

Axiom rliteral_axiom1 : True.

(* Why3 assumption *)
Definition infix_dlls (t1:real_term) (t2:real_term) : formula :=
  Atom
  (Pred rliteral1
   (Init.Datatypes.cons (RealT t1)
    (Init.Datatypes.cons (RealT t2) Init.Datatypes.nil))).

Parameter rliteral2: Strings.String.string.

Axiom rliteral_axiom2 : True.

(* Why3 assumption *)
Definition infix_dlgt (t1:real_term) (t2:real_term) : formula :=
  Atom
  (Pred rliteral2
   (Init.Datatypes.cons (RealT t1)
    (Init.Datatypes.cons (RealT t2) Init.Datatypes.nil))).

Parameter rliteral3: Strings.String.string.

Axiom rliteral_axiom3 : True.

(* Why3 assumption *)
Definition infix_dleq (t1:real_term) (t2:real_term) : formula :=
  Atom
  (Pred rliteral3
   (Init.Datatypes.cons (RealT t1)
    (Init.Datatypes.cons (RealT t2) Init.Datatypes.nil))).

Parameter rliteral4: Strings.String.string.

Axiom rliteral_axiom4 : True.

(* Why3 assumption *)
Definition infix_dlexeq (t1:real_term) (t2:real_term) : formula :=
  Atom
  (Pred rliteral4
   (Init.Datatypes.cons (RealT t1)
    (Init.Datatypes.cons (RealT t2) Init.Datatypes.nil))).

Parameter rliteral5: Strings.String.string.

Axiom rliteral_axiom5 : True.

(* Why3 assumption *)
Definition infix_dllseq (t1:real_term) (t2:real_term) : formula :=
  Atom
  (Pred rliteral5
   (Init.Datatypes.cons (RealT t1)
    (Init.Datatypes.cons (RealT t2) Init.Datatypes.nil))).

Parameter rliteral6: Strings.String.string.

Axiom rliteral_axiom6 : True.

(* Why3 assumption *)
Definition infix_dlgteq (t1:real_term) (t2:real_term) : formula :=
  Atom
  (Pred rliteral6
   (Init.Datatypes.cons (RealT t1)
    (Init.Datatypes.cons (RealT t2) Init.Datatypes.nil))).

Parameter rliteral7: Strings.String.string.

Axiom rliteral_axiom7 : True.

Axiom Atom_nil :
  forall (w:world), ~ infix_breq w (Atom (Pred rliteral7 Init.Datatypes.nil)).

Axiom Real_equal :
  forall (tx:real_term) (ty:real_term)
    (st:Init.Datatypes.list (Strings.String.string* formula* pvalue)%type)
    (i:real_term -> Reals.Rdefinitions.R),
  infix_breq (World st i) (infix_dleq tx ty) <-> ((i tx) = (i ty)).

Axiom Real_equal_refl :
  forall (tx:real_term) (w:world), infix_breq w (infix_dleq tx tx).

Axiom Real_equal_symm :
  forall (tx:real_term) (ty:real_term) (w:world),
  infix_breq w (infix_dleq tx ty) <-> infix_breq w (infix_dleq ty tx).

Axiom Real_equal_trans :
  forall (tx:real_term) (ty:real_term) (tz:real_term) (w:world),
  infix_breq w (infix_dleq tx ty) -> infix_breq w (infix_dleq ty tz) ->
  infix_breq w (infix_dleq tx tz).

Axiom Real_neq :
  forall (tx:real_term) (ty:real_term) (w:world),
  infix_breq w (infix_dlexeq tx ty) <-> infix_breq w (Not (infix_dleq tx ty)).

Axiom Real_less :
  forall (tx:real_term) (ty:real_term)
    (st:Init.Datatypes.list (Strings.String.string* formula* pvalue)%type)
    (i:real_term -> Reals.Rdefinitions.R),
  infix_breq (World st i) (infix_dlls tx ty) <-> ((i tx) < (i ty))%R.

Axiom Real_greater :
  forall (tx:real_term) (ty:real_term)
    (st:Init.Datatypes.list (Strings.String.string* formula* pvalue)%type)
    (i:real_term -> Reals.Rdefinitions.R),
  infix_breq (World st i) (infix_dlgt tx ty) <-> ((i ty) < (i tx))%R.

Axiom Real_leq :
  forall (tx:real_term) (ty:real_term)
    (st:Init.Datatypes.list (Strings.String.string* formula* pvalue)%type)
    (i:real_term -> Reals.Rdefinitions.R),
  infix_breq (World st i) (infix_dllseq tx ty) <-> ((i tx) <= (i ty))%R.

Axiom Real_geq :
  forall (tx:real_term) (ty:real_term)
    (st:Init.Datatypes.list (Strings.String.string* formula* pvalue)%type)
    (i:real_term -> Reals.Rdefinitions.R),
  infix_breq (World st i) (infix_dlgteq tx ty) <-> ((i ty) <= (i tx))%R.

Axiom Real_interp_leq :
  forall (tx:real_term) (ty:real_term) (i:real_term -> Reals.Rdefinitions.R),
  ((i tx) = (i ty)) \/ ((i tx) < (i ty))%R <-> ((i tx) <= (i ty))%R.

Axiom neq_tautology :
  forall (t1:real_term) (t2:real_term) (w:world),
  infix_breq w (infix_dlls t1 t2) <-> infix_breq w (infix_dlgt t2 t1).

Axiom not_neq_implies_eq :
  forall (t1:real_term) (t2:real_term) (w:world),
  infix_breq w (infix_dlexeq t1 t2) <-> ~ infix_breq w (infix_dleq t1 t2).

Axiom leq_or_eq_or_geq :
  forall (t1:real_term) (t2:real_term) (w:world),
  infix_breq w (infix_dleq t1 t2) \/
  infix_breq w (infix_dlls t1 t2) \/ infix_breq w (infix_dlgt t1 t2).

Axiom not_eq_implies_leq_or_geq :
  forall (t1:real_term) (t2:real_term) (w:world),
  ~ infix_breq w (infix_dleq t1 t2) ->
  infix_breq w (infix_dlls t1 t2) \/ infix_breq w (infix_dlgt t1 t2).

Axiom neq_implies_leq_or_geq :
  forall (t1:real_term) (t2:real_term) (w:world),
  infix_breq w (infix_dlexeq t1 t2) ->
  infix_breq w (infix_dlls t1 t2) \/ infix_breq w (infix_dlgt t1 t2).

Axiom eq_real_number_soundness :
  forall (r1:real_number) (r2:real_number) (w:world), eq_real_number r1 r2 ->
  infix_breq w (infix_dleq (Real r1) (Real r2)).

(* Why3 assumption *)
Definition sampled {a:Type} {a_WT:WhyType a} (y:a) (p:population) : Prop :=
  (((ppl : a -> population) y) = p).

Axiom normal_distribution_mean :
  forall (m:real_number) (v:real_number) (w:world),
  infix_breq w (infix_dleq (mean (NormalD m v)) (Real m)).

Axiom normal_distribution_var :
  forall (m:real_number) (v:real_number) (w:world),
  infix_breq w (infix_dleq (var (NormalD m v)) (Real v)).

Parameter bernoullip: population -> real_term.

Axiom bernoullip_def :
  forall (p:real_number), ((bernoullip (BernoulliD p)) = (Real p)).

Parameter rliteral8: Strings.String.string.

Axiom rliteral_axiom8 : True.

(* Why3 assumption *)
Definition check_variance (p:population) : formula :=
  Atom
  (Pred rliteral8 (Init.Datatypes.cons (PopulationT p) Init.Datatypes.nil)).

Axiom check_variance_def :
  forall (p:population) (w:world),
  infix_breq w (check_variance p) <->
  (exists r:Reals.Rdefinitions.R,
   infix_breq w (Know (infix_dleq (var p) (const_term r)))).

Axiom Ppl_check_variance_normald_const :
  forall (mean1:real_number) (s:Reals.Rdefinitions.R) (w:world),
  infix_breq w (check_variance (NormalD mean1 (Const s))).

(* Why3 goal *)
Theorem Ppl_check_variance_normald_param :
  forall (mean1:real_number) (s:Strings.String.string) (w:world),
  ~ infix_breq w (check_variance (NormalD mean1 (Param s))).
(* Why3 intros mean1 s w. *)
Proof.
intros mean1 s w.
intros C.
rewrite check_variance_def in C.
destruct C as [r C].
destruct w as [st interp].
rewrite ax_k_interpretation in C.
assert (F : exists k : real_term -> real, ~ (k (Real (Param s)) = k (Real (Const r)))).
{
  set (k := fun t => match t with
                    | Real (Param s') => if String.eqb s' s then Rplus r 1 else r
                    | Real (Const r') => r'
                    end).
  exists k.
  simpl.
  rewrite String.eqb_refl.
  intros H.
  assert (H0 : ((r + 1) + (-r) = r + (-r))%R).
  {
    rewrite H.
    reflexivity.
  }
  rewrite Rplus_assoc in H0.
  rewrite Rplus_opp_r in H0.
  rewrite Rplus_comm in H0.
  rewrite -> Rplus_assoc in H0.
  rewrite Rplus_opp_l in H0.
  rewrite Rplus_0_r in H0.
  apply R1_neq_R0.
  exact H0.  
}
destruct F as [k F].
set (C' := C k).
assert (H : k (Real (Param s)) = k (Real (Const r))).
{
  rewrite Real_equal_symm in C'.
  set (F0 := normal_distribution_var mean1 (Param s) (World st k)).
  apply (Real_equal_trans (const_term r) (var (NormalD mean1 (Param s))) (Real (Param s)) (World st k) C') in F0.
  rewrite Real_equal_symm in F0.
  apply (Real_equal (Real (Param s)) (Real (Const r)) st k).
  exact F0.
}
contradiction (F H).
Qed.
