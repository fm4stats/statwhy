(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require list.List.
Require list.Length.
Require list.Mem.
Require list.Append.

(* Why3 assumption *)
Fixpoint fold {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
  (f:b -> a -> b) (acc:b) (lst:Init.Datatypes.list a) {struct lst}: b :=
  match lst with
  | Init.Datatypes.nil => acc
  | Init.Datatypes.cons x r => fold f (f acc x) r
  end.

(* Why3 assumption *)
Fixpoint foldr {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
  (f:b -> a -> b) (acc:b) (lst:Init.Datatypes.list a) {struct lst}: b :=
  match lst with
  | Init.Datatypes.nil => acc
  | Init.Datatypes.cons x r => f (foldr f acc r) x
  end.

Axiom fold__append :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (l1:Init.Datatypes.list a) (l2:Init.Datatypes.list a)
    (f:b -> a -> b) (acc:b),
  ((fold f acc (Init.Datatypes.app l1 l2)) = (fold f (fold f acc l1) l2)).

(* Why3 assumption *)
Fixpoint map {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b} (f:a -> b)
  (lst:Init.Datatypes.list a) {struct lst}: Init.Datatypes.list b :=
  match lst with
  | Init.Datatypes.nil => Init.Datatypes.nil
  | Init.Datatypes.cons x xs => Init.Datatypes.cons (f x) (map f xs)
  end.

Parameter result:
  forall {a:Type} {a_WT:WhyType a}, (a -> Init.Datatypes.bool) ->
  Init.Datatypes.bool -> a -> Init.Datatypes.bool.

Axiom result'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (p:a -> Init.Datatypes.bool) (acc:Init.Datatypes.bool) (t:a),
  ((result p acc t) = Init.Datatypes.true) <->
  (acc = Init.Datatypes.true) /\ ((p t) = Init.Datatypes.true).

(* Why3 assumption *)
Definition for_all {a:Type} {a_WT:WhyType a} (p:a -> Init.Datatypes.bool)
    (l:Init.Datatypes.list a) : Init.Datatypes.bool :=
  fold (result p) Init.Datatypes.true l.

(* Why3 goal *)
Theorem for_all_correctness {a:Type} {a_WT:WhyType a} :
  forall (p:a -> Init.Datatypes.bool) (l:Init.Datatypes.list a),
  ((for_all p l) = Init.Datatypes.true) <->
  (forall (x:a), list.Mem.mem x l -> ((p x) = Init.Datatypes.true)).
Proof.
  assert (L1 : forall (p : a -> bool) (l : list a) (a0 : a) (b : bool), fold (result p) (result p b a0) l = true -> result p b a0 = true).
  {
    intros p l.
    induction l.
    - intros.
      simpl in H.
      apply H.
    - intros.
      simpl in H.
      apply IHl in H.
      apply result'def in H.
      destruct H.
      apply H.
  }
  intros p l.
  split.
  - induction l.
    + simpl. intros. destruct H0.
    + simpl. intros.
      unfold for_all in H.
      simpl in H.
      apply L1 in H as F1.
      rewrite F1 in H.
      assert (F2 : fold (result p) true l = for_all p l).
      {
        unfold for_all.
        reflexivity.
      }
      rewrite F2 in H.
      destruct H0 as [H0 | H0].
      * apply result'def in F1.
        destruct F1 as [_  F1'].
        rewrite H0.
        apply F1'.
      * apply IHl with (x:= x) in H.
        -- apply H.
        -- apply H0.
  - induction l.
    + intros.
      unfold for_all.
      simpl. reflexivity.
    + intros.
      unfold for_all.
      simpl.
      simpl in H.
      assert (F0 : p a0 = true).
      {
        apply H.
        left. reflexivity.
      }
      assert (F1 : result p true a0 = true).
      {
        apply result'def.
        split.
        reflexivity. apply F0.
      }
      rewrite F1.
      replace (fold (result p) true l) with (for_all p l).
      {
        apply IHl.
        intros.
        apply H.
        right.
        apply H0.
      }
      unfold for_all.
      reflexivity.
Qed.

