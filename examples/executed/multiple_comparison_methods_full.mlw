module Tukey_HSD_example
  use cameleerBHL.CameleerBHL
  use tukey_HSD.Tukey_HSD
  use array.Array

  let function mu1 : parameter = "mu1"
  let function mu2 : parameter = "mu2"
  let function mu3 : parameter = "mu3"
  let function mu4 : parameter = "mu4"
  let function mu5 : parameter = "mu5"
  let function mu6 : parameter = "mu6"
  let function mu7 : parameter = "mu7"
  let function mu8 : parameter = "mu8"
  let function mu9 : parameter = "mu9"
  
  let function p1 : population = NormalD (Param mu1) (Param "var")
  let function p2 : population = NormalD (Param mu2) (Param "var")
  let function p3 : population = NormalD (Param mu3) (Param "var")
  let function p4 : population = NormalD (Param mu4) (Param "var")
  let function p5 : population = NormalD (Param mu5) (Param "var")
  let function p6 : population = NormalD (Param mu6) (Param "var")
  let function p7 : population = NormalD (Param mu7) (Param "var")
  let function p8 : population = NormalD (Param mu8) (Param "var")
  let function p9 : population = NormalD (Param mu9) (Param "var")

  let function t_mu1 = RealT (mean p1)
  let function t_mu2 = RealT (mean p2)
  let function t_mu3 = RealT (mean p3)
  let function t_mu4 = RealT (mean p4)
  let function t_mu5 = RealT (mean p5)
  let function t_mu6 = RealT (mean p6)
  let function t_mu7 = RealT (mean p7)
  let function t_mu8 = RealT (mean p8)
  let function t_mu9 = RealT (mean p9)

  let function terms2 = (Cons t_mu1 (Cons t_mu2 Nil))

  let ex_tukey_hsd2 (d1 d2 : (list real)) : array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 (Cons d2 Nil))
                 (Cons p1 (Cons p2 Nil)) /\
               for_all (fun fml -> (World !st interp) |= Possible fml) (combinations terms2 "<") /\
               for_all (fun fml -> (World !st interp) |= Possible fml) (combinations terms2 ">")
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,fml) = t in
                (Eq (ps[i]) = compose_pvs fml !st) &&
                (World !st interp |= StatB (Eq (ps[i])) fml))
              (enumerate (combinations terms2 "!=") 0)
    }
    = exec_tukey_hsd (Cons p1 (Cons p2 Nil)) (Cons d1 (Cons d2 Nil))
  
  let function terms3 = (Cons t_mu1 (Cons t_mu2 (Cons t_mu3 Nil)))

  let ex_tukey_hsd3 (d1 d2 d3 : (list real)) : array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 (Cons d2 (Cons d3 Nil)))
                 (Cons p1 (Cons p2 (Cons p3 Nil))) /\
               for_all (fun fml -> (World !st interp) |= Possible fml) (combinations terms3 "<") /\
               for_all (fun fml -> (World !st interp) |= Possible fml) (combinations terms3 ">")
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,fml) = t in
                (Eq (ps[i]) = compose_pvs fml !st) &&
                (World !st interp |= StatB (Eq (ps[i])) fml))
              (enumerate (combinations terms3 "!=") 0)
    }
    = exec_tukey_hsd (Cons p1 (Cons p2 (Cons p3 Nil))) (Cons d1 (Cons d2 (Cons d3 Nil)))

  let function terms4 = (Cons t_mu1 (Cons t_mu2 (Cons t_mu3 (Cons t_mu4 Nil))))

  let ex_tukey_hsd4 (d1 d2 d3 d4 : (list real)) : array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 (Cons d2 (Cons d3 (Cons d4 Nil))))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 Nil)))) /\
               for_all (fun fml -> (World !st interp) |= Possible fml) (combinations terms4 "<") /\
               for_all (fun fml -> (World !st interp) |= Possible fml) (combinations terms4 ">")
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,fml) = t in
                (Eq (ps[i]) = compose_pvs fml !st) &&
                (World !st interp |= StatB (Eq (ps[i])) fml))
              (enumerate (combinations terms4 "!=") 0)
    }
    = exec_tukey_hsd (Cons p1 (Cons p2 (Cons p3 (Cons p4 Nil)))) (Cons d1 (Cons d2 (Cons d3 (Cons d4 Nil))))

  let function terms5 = (Cons t_mu1 (Cons t_mu2 (Cons t_mu3 (Cons t_mu4 (Cons t_mu5 Nil)))))
  
  let ex_tukey_hsd5 (d1 d2 d3 d4 d5 : (list real)) : array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 Nil)))))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 Nil))))) /\
               for_all (fun fml -> (World !st interp) |= Possible fml) (combinations terms5 "<") /\
               for_all (fun fml -> (World !st interp) |= Possible fml) (combinations terms5 ">")
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,fml) = t in
                (Eq (ps[i]) = compose_pvs fml !st) &&
                (World !st interp |= StatB (Eq (ps[i])) fml))
              (enumerate (combinations terms5 "!=") 0)
    }
    = exec_tukey_hsd (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 Nil)))))
                     (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 Nil)))))

  let function terms6 = (Cons t_mu1 (Cons t_mu2 (Cons t_mu3 (Cons t_mu4 (Cons t_mu5 (Cons t_mu6 Nil))))))
  
  let ex_tukey_hsd6 (d1 d2 d3 d4 d5 d6: (list real)) : array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 (Cons d6 Nil))))))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 Nil)))))) /\
               for_all (fun fml -> (World !st interp) |= Possible fml) (combinations terms6 "<") /\
               for_all (fun fml -> (World !st interp) |= Possible fml) (combinations terms6 ">")
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,fml) = t in
                (Eq (ps[i]) = compose_pvs fml !st) &&
                (World !st interp |= StatB (Eq (ps[i])) fml))
              (enumerate (combinations terms6 "!=") 0)
    }
    = exec_tukey_hsd (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 Nil)))))) (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 (Cons d6 Nil))))))

  let function terms7 =
    (Cons t_mu1 (Cons t_mu2 (Cons t_mu3 (Cons t_mu4 (Cons t_mu5 (Cons t_mu6 (Cons t_mu7 Nil)))))))

  let ex_tukey_hsd7 (d1 d2 d3 d4 d5 d6 d7 : (list real)) : array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 (Cons d6 (Cons d7 Nil)))))))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 (Cons p7 Nil))))))) /\
               for_all (fun fml -> (World !st interp) |= Possible fml ) (combinations terms7 "<") /\
               for_all (fun fml -> (World !st interp) |= Possible fml ) (combinations terms7 ">")
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,fml) = t in
                (Eq (ps[i]) = compose_pvs fml !st) &&
                (World !st interp |= StatB (Eq (ps[i])) fml))
              (enumerate (combinations terms7 "!=") 0)
    }
    = exec_tukey_hsd (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 (Cons p7 Nil))))))) (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 (Cons d6 (Cons d7 Nil)))))))

  let function terms9 =
    (Cons t_mu1 (Cons t_mu2 (Cons t_mu3 (Cons t_mu4 (Cons t_mu5 (Cons t_mu6 (Cons t_mu7 (Cons t_mu8 (Cons t_mu9 Nil)))))))))

  let ex_tukey_hsd9 (d1 d2 d3 d4 d5 d6 d7 d8 d9 : (list real)) : array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 (Cons d6 (Cons d7 (Cons d8 (Cons d9 Nil)))))))))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 (Cons p7 (Cons p8 (Cons p9 Nil))))))))) /\
               for_all (fun fml -> (World !st interp) |= Possible fml ) (combinations terms9 "<") /\
               for_all (fun fml -> (World !st interp) |= Possible fml ) (combinations terms9 ">")
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,fml) = t in
                (Eq (ps[i]) = compose_pvs fml !st) &&
                (World !st interp |= StatB (Eq (ps[i])) fml))
              (enumerate (combinations terms9 "!=") 0)
    }
    = exec_tukey_hsd
        (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 (Cons p7 (Cons p8 (Cons p9 Nil)))))))))
        (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 (Cons d6 (Cons d7 (Cons d8 (Cons d9 Nil)))))))))
end


module Dunnett_example
  use cameleerBHL.CameleerBHL
  use dunnett.Dunnett
  use array.Array

  let function mu0 = "mu0"
  let function p0  = NormalD (Param mu0) (Const 1.0)
  let function t_mu0 = RealT (mean p0)

  let function mu1 = "mu1"
  let function mu2 = "mu2"
  let function mu3 = "mu3"
  let function mu4 = "mu4"
  let function mu5 = "mu5"
  let function mu6 = "mu6"
  let function mu7 = "mu7"

  let function p1 = NormalD (Param mu1) (Const 1.0)
  let function p2 = NormalD (Param mu2) (Const 1.0)
  let function p3 = NormalD (Param mu3) (Const 1.0)
  let function p4 = NormalD (Param mu4) (Const 1.0)
  let function p5 = NormalD (Param mu5) (Const 1.0)
  let function p6 = NormalD (Param mu6) (Const 1.0)
  let function p7 = NormalD (Param mu7) (Const 1.0)

  let ex_dunnett1 (d1 : (list real)) (c : list real) : array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 Nil)
                 (Cons p1 Nil) /\
               sampled c p0 /\
               for_all
                 (fun p -> (World !st interp) |= Possible (mean p0 $< mean p) /\
                           (World !st interp) |= Possible (mean p0 $> mean p))
                 (Cons p1 Nil)
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,p) = t in
                (Eq (ps[i]) = compose_pvs (mean p0 $!= mean p) !st) &&
                (World !st interp |= StatB (Eq (ps[i])) (mean p0 $!= mean p)))
              (enumerate (Cons p1 Nil) 0)
    }
    = exec_dunnett (Cons p1 Nil) p0 (Cons d1 Nil) c Two

  let ex_dunnett2 (d1 d2 : (list real)) (c : list real) : array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 (Cons d2 Nil))
                 (Cons p1 (Cons p2 Nil)) /\
               sampled c p0 /\
               for_all
                 (fun p -> (World !st interp) |= Possible (mean p0 $< mean p) /\
                           (World !st interp) |= Possible (mean p0 $> mean p))
                 (Cons p1 (Cons p2 Nil))
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,p) = t in
                (Eq (ps[i]) = compose_pvs (mean p0 $!= mean p) !st) &&
                (World !st interp |= StatB (Eq (ps[i])) (mean p0 $!= mean p)))
              (enumerate (Cons p1 (Cons p2 Nil)) 0)
    }
    = exec_dunnett (Cons p1 (Cons p2 Nil)) p0 (Cons d1 (Cons d2 Nil)) c Two

  let ex_dunnett3 (d1 d2 d3 : (list real)) (c : list real) : array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 (Cons d2 (Cons d3 Nil)))
                 (Cons p1 (Cons p2 (Cons p3 Nil))) /\
               sampled c p0 /\
               for_all
                 (fun p -> (World !st interp) |= Possible (mean p0 $< mean p) /\
                           (World !st interp) |= Possible (mean p0 $> mean p))
                 (Cons p1 (Cons p2 (Cons p3 Nil)))
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,p) = t in
                (Eq (ps[i]) = compose_pvs (mean p0 $!= mean p) !st) &&
                (World !st interp |= StatB (Eq (ps[i])) (mean p0 $!= mean p)))
              (enumerate (Cons p1 (Cons p2 (Cons p3 Nil))) 0)
    }
    = exec_dunnett (Cons p1 (Cons p2 (Cons p3 Nil))) p0 (Cons d1 (Cons d2 (Cons d3 Nil))) c Two

  let ex_dunnett4 (d1 d2 d3 d4 : (list real)) (c : list real) : array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 (Cons d2 (Cons d3 (Cons d4 Nil))))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 Nil)))) /\
               sampled c p0 /\
               for_all
                 (fun p -> (World !st interp) |= Possible (mean p0 $< mean p) /\
                           (World !st interp) |= Possible (mean p0 $> mean p))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 Nil))))
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,p) = t in
                (Eq (ps[i]) = compose_pvs (mean p0 $!= mean p) !st) &&
                (World !st interp |= StatB (Eq (ps[i])) (mean p0 $!= mean p)))
              (enumerate
                (Cons p1 (Cons p2 (Cons p3 (Cons p4 Nil))))
                0)
    }
    = exec_dunnett (Cons p1 (Cons p2 (Cons p3 (Cons p4 Nil)))) p0 (Cons d1 (Cons d2 (Cons d3 (Cons d4 Nil)))) c Two

  let ex_dunnett5 (d1 d2 d3 d4 d5 : (list real)) (c : list real): array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 Nil)))))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 Nil))))) /\
               sampled c p0 /\
               for_all
                 (fun p -> (World !st interp) |= Possible (mean p0 $< mean p) /\
                           (World !st interp) |= Possible (mean p0 $> mean p))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 Nil)))))
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,p) = t in
                (Eq (ps[i]) = compose_pvs (mean p0 $!= mean p) !st) &&
                (World !st interp |= StatB (Eq (ps[i])) (mean p0 $!= mean p)))
              (enumerate
                (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 Nil)))))
                0)
    }
    = exec_dunnett (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 Nil))))) p0
                 (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 Nil))))) c Two

  let ex_dunnett6 (d1 d2 d3 d4 d5 d6 : (list real)) (c : list real): array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 (Cons d6 Nil))))))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 Nil)))))) /\
               sampled c p0 /\
               for_all
                 (fun p -> (World !st interp) |= Possible (mean p0 $< mean p) /\
                           (World !st interp) |= Possible (mean p0 $> mean p))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 Nil))))))
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,p) = t in
                (Eq (ps[i]) = compose_pvs (mean p0 $!= mean p) !st) &&
                (World !st interp |= StatB (Eq (ps[i])) (mean p0 $!= mean p)))
              (enumerate
                (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 Nil))))))
                0)
    }
    = exec_dunnett (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 Nil)))))) p0
                 (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 (Cons d6 Nil)))))) c Two

  let ex_dunnett7 (d1 d2 d3 d4 d5 d6 d7 : (list real)) (c : list real): array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 (Cons d6 (Cons d7 Nil)))))))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 (Cons p7 Nil))))))) /\
               sampled c p0 /\
               for_all
                 (fun p -> (World !st interp) |= Possible (mean p0 $< mean p) /\
                           (World !st interp) |= Possible (mean p0 $> mean p))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 (Cons p7 Nil)))))))
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,p) = t in
                (Eq (ps[i]) = compose_pvs (mean p0 $!= mean p) !st) &&
                (World !st interp |= StatB (Eq (ps[i])) (mean p0 $!= mean p)))
              (enumerate
                (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 (Cons p7 Nil)))))))
                0)
    }
    = exec_dunnett
        (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 (Cons p7 Nil))))))) p0
        (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 (Cons d6 (Cons d7 Nil))))))) c Two
end


module Williams_example
  use cameleerBHL.CameleerBHL
  use williams.Williams
  use array.Array

  let function mu0 = "mu0"
  let function p0  = NormalD (Param mu0) (Const 1.0)
  let function t_mu0 = RealT (mean p0)

  let function mu1 = "mu1"
  let function mu2 = "mu2"
  let function mu3 = "mu3"
  let function mu4 = "mu4"
  let function mu5 = "mu5"
  let function mu6 = "mu6"
  let function mu7 = "mu7"

  let function p1 = NormalD (Param mu1) (Const 1.0)
  let function p2 = NormalD (Param mu2) (Const 1.0)
  let function p3 = NormalD (Param mu3) (Const 1.0)
  let function p4 = NormalD (Param mu4) (Const 1.0)
  let function p5 = NormalD (Param mu5) (Const 1.0)
  let function p6 = NormalD (Param mu6) (Const 1.0)
  let function p7 = NormalD (Param mu7) (Const 1.0)

  let ex_williams1 (d1 : (list real)) (c : list real) : array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 Nil)
                 (Cons p1 Nil) /\
               sampled c p0 /\
               for_all
                 (fun p -> (World !st interp) |= Not (Possible (mean p0 $< mean p)) /\
                           (World !st interp) |= Possible (mean p0 $> mean p))
                 (Cons p1 Nil) /\
               ((World !st interp) |= Know (mean p1 $<= mean p0))
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,p) = t in
                (Eq (ps[i]) = compose_pvs (mean p0 $> mean p) !st) &&
                (World !st interp |= StatB (Eq (ps[i])) (mean p0 $> mean p)))
              (enumerate (Cons p1 Nil) 0)
    }
    = exec_williams (Cons p1 Nil) p0 (Cons d1 Nil) c Up

  let ex_williams2 (d1 d2 : (list real)) (c : list real) : array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 (Cons d2 Nil))
                 (Cons p1 (Cons p2 Nil)) /\
               sampled c p0 /\
               for_all
                 (fun p -> (World !st interp) |= Not (Possible (mean p0 $< mean p)) /\
                           (World !st interp) |= Possible (mean p0 $> mean p))
                 (Cons p1 (Cons p2 Nil)) /\
               ((World !st interp) |= Know (mean p1 $<= mean p2)) /\
               ((World !st interp) |= Know (mean p2 $<= mean p0))
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,p) = t in
                (Eq (ps[i]) = compose_pvs (mean p0 $> mean p) !st) &&
                (World !st interp |= StatB (Eq (ps[i])) (mean p0 $> mean p)))
              (enumerate (Cons p1 (Cons p2 Nil)) 0)
    }
    = exec_williams (Cons p1 (Cons p2 Nil)) p0 (Cons d1 (Cons d2 Nil)) c Up

  let ex_williams3 (d1 d2 d3 : (list real)) (c : list real) : array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 (Cons d2 (Cons d3 Nil)))
                 (Cons p1 (Cons p2 (Cons p3 Nil))) /\
               sampled c p0 /\
               for_all
                 (fun p -> (World !st interp) |= Not (Possible (mean p0 $< mean p)) /\
                           (World !st interp) |= Possible (mean p0 $> mean p))
                 (Cons p1 (Cons p2 (Cons p3 Nil))) /\
               ((World !st interp) |= Know (mean p1 $<= mean p2)) /\
               ((World !st interp) |= Know (mean p2 $<= mean p3)) /\
               ((World !st interp) |= Know (mean p3 $<= mean p0))
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,p) = t in
                (Eq (ps[i]) = compose_pvs (mean p0 $> mean p) !st) &&
                (World !st interp |= StatB (Eq (ps[i])) (mean p0 $> mean p)))
              (enumerate (Cons p1 (Cons p2 (Cons p3 Nil))) 0)
    }
    = exec_williams (Cons p1 (Cons p2 (Cons p3 Nil))) p0 (Cons d1 (Cons d2 (Cons d3 Nil))) c Up

  let ex_williams4 (d1 d2 d3 d4 : (list real)) (c : list real) : array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 (Cons d2 (Cons d3 (Cons d4 Nil))))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 Nil)))) /\
               sampled c p0 /\
               for_all
                 (fun p -> (World !st interp) |= Not (Possible (mean p0 $< mean p)) /\
                           (World !st interp) |= Possible (mean p0 $> mean p))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 Nil)))) /\
               ((World !st interp) |= Know (mean p1 $<= mean p2)) /\
               ((World !st interp) |= Know (mean p2 $<= mean p3)) /\
               ((World !st interp) |= Know (mean p3 $<= mean p4)) /\
               ((World !st interp) |= Know (mean p4 $<= mean p0))
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,p) = t in
                (Eq (ps[i]) = compose_pvs (mean p0 $> mean p) !st) &&
                (World !st interp |= StatB (Eq (ps[i])) (mean p0 $> mean p)))
              (enumerate
                (Cons p1 (Cons p2 (Cons p3 (Cons p4 Nil))))
                0)
    }
    = exec_williams (Cons p1 (Cons p2 (Cons p3 (Cons p4 Nil)))) p0 (Cons d1 (Cons d2 (Cons d3 (Cons d4 Nil)))) c Up

  let ex_williams5 (d1 d2 d3 d4 d5 : (list real)) (c : list real): array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 Nil)))))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 Nil))))) /\
               sampled c p0 /\
               for_all
                 (fun p -> (World !st interp) |= Not (Possible (mean p0 $< mean p)) /\
                           (World !st interp) |= Possible (mean p0 $> mean p))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 Nil))))) /\
               ((World !st interp) |= Know (mean p1 $<= mean p2)) /\
               ((World !st interp) |= Know (mean p2 $<= mean p3)) /\
               ((World !st interp) |= Know (mean p3 $<= mean p4)) /\
               ((World !st interp) |= Know (mean p4 $<= mean p5)) /\
               ((World !st interp) |= Know (mean p5 $<= mean p0))
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,p) = t in
                (Eq (ps[i]) = compose_pvs (mean p0 $> mean p) !st) &&
                (World !st interp |= StatB (Eq (ps[i])) (mean p0 $> mean p)))
              (enumerate
                (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 Nil)))))
                0)
    }
    = exec_williams (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 Nil))))) p0
                   (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 Nil))))) c Up

  let ex_williams6 (d1 d2 d3 d4 d5 d6 : (list real)) (c : list real): array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 (Cons d6 Nil))))))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 Nil)))))) /\
               sampled c p0 /\
               for_all
                 (fun p -> (World !st interp) |= Not (Possible (mean p0 $< mean p)) /\
                           (World !st interp) |= Possible (mean p0 $> mean p))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 Nil)))))) /\
               ((World !st interp) |= Know (mean p1 $<= mean p2)) /\
               ((World !st interp) |= Know (mean p2 $<= mean p3)) /\
               ((World !st interp) |= Know (mean p3 $<= mean p4)) /\
               ((World !st interp) |= Know (mean p4 $<= mean p5)) /\
               ((World !st interp) |= Know (mean p5 $<= mean p6)) /\
               ((World !st interp) |= Know (mean p6 $<= mean p0))
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,p) = t in
                (Eq (ps[i]) = compose_pvs (mean p0 $> mean p) !st) &&
                (World !st interp |= StatB (Eq (ps[i])) (mean p0 $> mean p)))
              (enumerate
                (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 Nil))))))
                0)
    }
    = exec_williams (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 Nil)))))) p0
                 (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 (Cons d6 Nil)))))) c Up

  let ex_williams7 (d1 d2 d3 d4 d5 d6 d7 : (list real)) (c : list real): array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 (Cons d6 (Cons d7 Nil)))))))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 (Cons p7 Nil))))))) /\
               sampled c p0 /\
               for_all
                 (fun p -> (World !st interp) |= Not (Possible (mean p0 $< mean p)) /\
                           (World !st interp) |= Possible (mean p0 $> mean p))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 (Cons p7 Nil))))))) /\
               ((World !st interp) |= Know (mean p1 $<= mean p2)) /\
               ((World !st interp) |= Know (mean p2 $<= mean p3)) /\
               ((World !st interp) |= Know (mean p3 $<= mean p4)) /\
               ((World !st interp) |= Know (mean p4 $<= mean p5)) /\
               ((World !st interp) |= Know (mean p5 $<= mean p6)) /\
               ((World !st interp) |= Know (mean p6 $<= mean p7)) /\
               ((World !st interp) |= Know (mean p7 $<= mean p0))
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,p) = t in
                (Eq (ps[i]) = compose_pvs (mean p0 $> mean p) !st) &&
                (World !st interp |= StatB (Eq (ps[i])) (mean p0 $> mean p)))
              (enumerate
                (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 (Cons p7 Nil)))))))
                0)
    }
    = exec_williams
        (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 (Cons p7 Nil))))))) p0
        (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 (Cons d6 (Cons d7 Nil))))))) c Up
end


module Steel_Dwass_example
  use cameleerBHL.CameleerBHL
  use steel_dwass.Steel_Dwass
  use array.Array

  let function p1 : population = UnknownD "p1"
  let function p2 : population = UnknownD "p2"
  let function p3 : population = UnknownD "p3"
  let function p4 : population = UnknownD "p4"
  let function p5 : population = UnknownD "p5"
  let function p6 : population = UnknownD "p6"
  let function p7 : population = UnknownD "p7"
  let function p8 : population = UnknownD "p8"
  let function p9 : population = UnknownD "p9"

  let function t_mu1 = RealT (mean p1)
  let function t_mu2 = RealT (mean p2)
  let function t_mu3 = RealT (mean p3)
  let function t_mu4 = RealT (mean p4)
  let function t_mu5 = RealT (mean p5)
  let function t_mu6 = RealT (mean p6)
  let function t_mu7 = RealT (mean p7)
  let function t_mu8 = RealT (mean p8)
  let function t_mu9 = RealT (mean p9)

  let function terms2 = (Cons t_mu1 (Cons t_mu2 Nil))

  let ex_steel_dwass2 (d1 d2 : (list real)) : array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 (Cons d2 Nil))
                 (Cons p1 (Cons p2 Nil)) /\
               (World !st interp)|= eq_variance p1 p2 /\
               for_all (fun fml -> (World !st interp) |= Possible fml) (combinations terms2 "<") /\
               for_all (fun fml -> (World !st interp) |= Possible fml) (combinations terms2 ">")
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,fml) = t in
                (Eq (ps[i]) = compose_pvs fml !st) &&
                (World !st interp |= StatB (Eq (ps[i])) fml))
              (enumerate (combinations terms2 "!=") 0)
    }
    = exec_steel_dwass (Cons p1 (Cons p2 Nil)) (Cons d1 (Cons d2 Nil))

  let function terms3 = (Cons t_mu1 (Cons t_mu2 (Cons t_mu3 Nil)))

  let ex_steel_dwass3 (d1 d2 d3 : (list real)) : array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 (Cons d2 (Cons d3 Nil)))
                 (Cons p1 (Cons p2 (Cons p3 Nil))) /\
               (World !st interp)|= eq_variance p1 p2 /\
               (World !st interp)|= eq_variance p2 p3 /\
               for_all (fun fml -> (World !st interp) |= Possible fml) (combinations terms3 "<") /\
               for_all (fun fml -> (World !st interp) |= Possible fml) (combinations terms3 ">")
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,fml) = t in
                (Eq (ps[i]) = compose_pvs fml !st) &&
                (World !st interp |= StatB (Eq (ps[i])) fml))
              (enumerate (combinations terms3 "!=") 0)
    }
    = exec_steel_dwass (Cons p1 (Cons p2 (Cons p3 Nil))) (Cons d1 (Cons d2 (Cons d3 Nil)))

  let function terms4 = (Cons t_mu1 (Cons t_mu2 (Cons t_mu3 (Cons t_mu4 Nil))))

  let ex_steel_dwass4 (d1 d2 d3 d4 : (list real)) : array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 (Cons d2 (Cons d3 (Cons d4 Nil))))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 Nil)))) /\
               (World !st interp)|= eq_variance p1 p2 /\
               (World !st interp)|= eq_variance p2 p3 /\
               (World !st interp)|= eq_variance p3 p4 /\
               for_all (fun fml -> (World !st interp) |= Possible fml) (combinations terms4 "<") /\
               for_all (fun fml -> (World !st interp) |= Possible fml) (combinations terms4 ">")
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,fml) = t in
                (Eq (ps[i]) = compose_pvs fml !st) &&
                (World !st interp |= StatB (Eq (ps[i])) fml))
              (enumerate (combinations terms4 "!=") 0)
    }
    = exec_steel_dwass (Cons p1 (Cons p2 (Cons p3 (Cons p4 Nil)))) (Cons d1 (Cons d2 (Cons d3 (Cons d4 Nil))))

  let function terms5 = (Cons t_mu1 (Cons t_mu2 (Cons t_mu3 (Cons t_mu4 (Cons t_mu5 Nil)))))
  
  let ex_steel_dwass5 (d1 d2 d3 d4 d5: (list real)) : array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 Nil)))))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 Nil))))) /\
               (World !st interp) |= eq_variance p1 p2 /\
               (World !st interp) |= eq_variance p2 p3 /\
               (World !st interp) |= eq_variance p3 p4 /\
               (World !st interp) |= eq_variance p4 p5 /\
               for_all (fun fml -> (World !st interp) |= Possible fml) (combinations terms5 "<") /\
               for_all (fun fml -> (World !st interp) |= Possible fml) (combinations terms5 ">")
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,fml) = t in
                (Eq (ps[i]) = compose_pvs fml !st) &&
                (World !st interp |= StatB (Eq (ps[i])) fml))
              (enumerate (combinations terms5 "!=") 0)
    }
    = exec_steel_dwass (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 Nil))))) (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 Nil)))))

  let function terms6 = (Cons t_mu1 (Cons t_mu2 (Cons t_mu3 (Cons t_mu4 (Cons t_mu5 (Cons t_mu6 Nil))))))
  
  let ex_steel_dwass6 (d1 d2 d3 d4 d5 d6: (list real)) : array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 (Cons d6 Nil))))))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 Nil)))))) /\
               (World !st interp) |= eq_variance p1 p2 /\
               (World !st interp) |= eq_variance p2 p3 /\
               (World !st interp) |= eq_variance p3 p4 /\
               (World !st interp) |= eq_variance p4 p5 /\
               (World !st interp) |= eq_variance p5 p6 /\
               for_all (fun fml -> (World !st interp) |= Possible fml) (combinations terms6 "<") /\
               for_all (fun fml -> (World !st interp) |= Possible fml) (combinations terms6 ">")
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,fml) = t in
                (Eq (ps[i]) = compose_pvs fml !st) &&
                (World !st interp |= StatB (Eq (ps[i])) fml))
              (enumerate (combinations terms6 "!=") 0)
    }
    = exec_steel_dwass (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 Nil)))))) (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 (Cons d6 Nil))))))


  let function terms7 =
    (Cons t_mu1 (Cons t_mu2 (Cons t_mu3 (Cons t_mu4 (Cons t_mu5 (Cons t_mu6 (Cons t_mu7 Nil)))))))

  let ex_steel_dwass7 (d1 d2 d3 d4 d5 d6 d7 : (list real)) : array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 (Cons d6 (Cons d7 Nil)))))))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 (Cons p7 Nil))))))) /\
               (World !st interp) |= eq_variance p1 p2 /\
               (World !st interp) |= eq_variance p2 p3 /\
               (World !st interp) |= eq_variance p3 p4 /\
               (World !st interp) |= eq_variance p4 p5 /\
               (World !st interp) |= eq_variance p5 p6 /\
               (World !st interp) |= eq_variance p6 p7 /\
               for_all (fun fml -> (World !st interp) |= Possible fml ) (combinations terms7 "<") /\
               for_all (fun fml -> (World !st interp) |= Possible fml ) (combinations terms7 ">")
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,fml) = t in
                (Eq (ps[i]) = compose_pvs fml !st) &&
                (World !st interp |= StatB (Eq (ps[i])) fml))
              (enumerate (combinations terms7 "!=") 0)
    }
    = exec_steel_dwass (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 (Cons p7 Nil))))))) (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 (Cons d6 (Cons d7 Nil)))))))


  let function terms9 =
    (Cons t_mu1 (Cons t_mu2 (Cons t_mu3 (Cons t_mu4 (Cons t_mu5 (Cons t_mu6 (Cons t_mu7 (Cons t_mu8 (Cons t_mu9 Nil)))))))))

  let ex_steel_dwass9 (d1 d2 d3 d4 d5 d6 d7 d8 d9 : (list real)) : array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 (Cons d6 (Cons d7 (Cons d8 (Cons d9 Nil)))))))))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 (Cons p7 (Cons p8 (Cons p9 Nil))))))))) /\
               (World !st interp) |= eq_variance p1 p2 /\
               (World !st interp) |= eq_variance p2 p3 /\
               (World !st interp) |= eq_variance p3 p4 /\
               (World !st interp) |= eq_variance p4 p5 /\
               (World !st interp) |= eq_variance p5 p6 /\
               (World !st interp) |= eq_variance p6 p7 /\
               (World !st interp) |= eq_variance p7 p8 /\
               (World !st interp) |= eq_variance p8 p9 /\
               for_all (fun fml -> (World !st interp) |= Possible fml ) (combinations terms9 "<") /\
               for_all (fun fml -> (World !st interp) |= Possible fml ) (combinations terms9 ">")
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,fml) = t in
                (Eq (ps[i]) = compose_pvs fml !st) &&
                (World !st interp |= StatB (Eq (ps[i])) fml))
              (enumerate (combinations terms9 "!=") 0)
    }
    = exec_steel_dwass
        (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 (Cons p7 (Cons p8 (Cons p9 Nil)))))))))
        (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 (Cons d6 (Cons d7 (Cons d8 (Cons d9 Nil)))))))))
end


module Steel_example
  use cameleerBHL.CameleerBHL
  use steel.Steel
  use array.Array

  let function p0  = UnknownD "p0"
  let function t_mu0 = RealT (mean p0)

  let function p1 = UnknownD "p1"
  let function p2 = UnknownD "p2"
  let function p3 = UnknownD "p3"
  let function p4 = UnknownD "p4"
  let function p5 = UnknownD "p5"
  let function p6 = UnknownD "p6"
  let function p7 = UnknownD "p7"

  let ex_steel1 (d1 : (list real)) (c : list real) : array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 Nil)
                 (Cons p1 Nil) /\
               sampled c p0 /\
               for_all
                 (fun p -> (World !st interp) |= eq_variance p0 p)
                 (Cons p1 Nil) /\
               for_all
                 (fun p -> (World !st interp) |= Possible (mean p0 $< mean p) /\
                           (World !st interp) |= Possible (mean p0 $> mean p))
                 (Cons p1 Nil)
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,p) = t in
                (Eq (ps[i]) = compose_pvs (mean p0 $!= mean p) !st) &&
                (World !st interp |= StatB (Eq (ps[i])) (mean p0 $!= mean p)))
              (enumerate (Cons p1 Nil) 0)
    }
    = exec_steel (Cons p1 Nil) p0 (Cons d1 Nil) c Two

  let ex_steel2 (d1 d2 : (list real)) (c : list real) : array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 (Cons d2 Nil))
                 (Cons p1 (Cons p2 Nil)) /\
               sampled c p0 /\
               for_all
                 (fun p -> (World !st interp) |= eq_variance p0 p)
                 (Cons p1 (Cons p2 Nil)) /\
               for_all
                 (fun p -> (World !st interp) |= Possible (mean p0 $< mean p) /\
                           (World !st interp) |= Possible (mean p0 $> mean p))
                 (Cons p1 (Cons p2 Nil))
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,p) = t in
                (Eq (ps[i]) = compose_pvs (mean p0 $!= mean p) !st) &&
                (World !st interp |= StatB (Eq (ps[i])) (mean p0 $!= mean p)))
              (enumerate (Cons p1 (Cons p2 Nil)) 0)
    }
    = exec_steel (Cons p1 (Cons p2 Nil)) p0 (Cons d1 (Cons d2 Nil)) c Two


  let ex_steel3 (d1 d2 d3 : (list real)) (c : list real) : array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 (Cons d2 (Cons d3 Nil)))
                 (Cons p1 (Cons p2 (Cons p3 Nil))) /\
               sampled c p0 /\
               for_all
                 (fun p -> (World !st interp) |= eq_variance p0 p)
                 (Cons p1 (Cons p2 (Cons p3 Nil))) /\
               for_all
                 (fun p -> (World !st interp) |= Possible (mean p0 $< mean p) /\
                           (World !st interp) |= Possible (mean p0 $> mean p))
                 (Cons p1 (Cons p2 (Cons p3 Nil)))
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,p) = t in
                (Eq (ps[i]) = compose_pvs (mean p0 $!= mean p) !st) &&
                (World !st interp |= StatB (Eq (ps[i])) (mean p0 $!= mean p)))
              (enumerate (Cons p1 (Cons p2 (Cons p3 Nil))) 0)
    }
    = exec_steel (Cons p1 (Cons p2 (Cons p3 Nil))) p0 (Cons d1 (Cons d2 (Cons d3 Nil))) c Two

  let ex_steel4 (d1 d2 d3 d4 : (list real)) (c : list real) : array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 (Cons d2 (Cons d3 (Cons d4 Nil))))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 Nil)))) /\
               sampled c p0 /\
               for_all
                 (fun p -> (World !st interp) |= eq_variance p0 p)
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 Nil)))) /\
               for_all
                 (fun p -> (World !st interp) |= Possible (mean p0 $< mean p) /\
                           (World !st interp) |= Possible (mean p0 $> mean p))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 Nil))))
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,p) = t in
                (Eq (ps[i]) = compose_pvs (mean p0 $!= mean p) !st) &&
                (World !st interp |= StatB (Eq (ps[i])) (mean p0 $!= mean p)))
              (enumerate
                (Cons p1 (Cons p2 (Cons p3 (Cons p4 Nil))))
                0)
    }
    = exec_steel (Cons p1 (Cons p2 (Cons p3 (Cons p4 Nil)))) p0 (Cons d1 (Cons d2 (Cons d3 (Cons d4 Nil)))) c Two

  let ex_steel5 (d1 d2 d3 d4 d5 : (list real)) (c : list real): array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 Nil)))))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 Nil))))) /\
               sampled c p0 /\
               for_all
                 (fun p -> (World !st interp) |= eq_variance p0 p)
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 Nil))))) /\
               for_all
                 (fun p -> (World !st interp) |= Possible (mean p0 $< mean p) /\
                           (World !st interp) |= Possible (mean p0 $> mean p))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 Nil)))))
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,p) = t in
                (Eq (ps[i]) = compose_pvs (mean p0 $!= mean p) !st) &&
                (World !st interp |= StatB (Eq (ps[i])) (mean p0 $!= mean p)))
              (enumerate
                (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 Nil)))))
                0)
    }
    = exec_steel (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 Nil))))) p0
                 (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 Nil))))) c Two

  let ex_steel6 (d1 d2 d3 d4 d5 d6 : (list real)) (c : list real): array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 (Cons d6 Nil))))))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 Nil)))))) /\
               sampled c p0 /\
               for_all
                 (fun p -> (World !st interp) |= eq_variance p0 p)
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 Nil)))))) /\
               for_all
                 (fun p -> (World !st interp) |= Possible (mean p0 $< mean p) /\
                           (World !st interp) |= Possible (mean p0 $> mean p))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 Nil))))))
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,p) = t in
                (Eq (ps[i]) = compose_pvs (mean p0 $!= mean p) !st) &&
                (World !st interp |= StatB (Eq (ps[i])) (mean p0 $!= mean p)))
              (enumerate
                (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 Nil))))))
                0)
    }
    = exec_steel (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 Nil)))))) p0
                 (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 (Cons d6 Nil)))))) c Two

  let ex_steel7 (d1 d2 d3 d4 d5 d6 d7 : (list real)) (c : list real): array real
    requires { !st = Nil /\
               for_all2
                 sampled
                 (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 (Cons d6 (Cons d7 Nil)))))))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 (Cons p7 Nil))))))) /\
               sampled c p0 /\
               for_all
                 (fun p -> (World !st interp) |= eq_variance p0 p)
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 (Cons p7 Nil))))))) /\
               for_all
                 (fun p -> (World !st interp) |= Possible (mean p0 $< mean p) /\
                           (World !st interp) |= Possible (mean p0 $> mean p))
                 (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 (Cons p7 Nil)))))))
             }
    ensures {
      let ps = result in
      for_all (fun t -> let (i,p) = t in
                (Eq (ps[i]) = compose_pvs (mean p0 $!= mean p) !st) &&
                (World !st interp |= StatB (Eq (ps[i])) (mean p0 $!= mean p)))
              (enumerate
                (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 (Cons p7 Nil)))))))
                0)
    }
    = exec_steel
        (Cons p1 (Cons p2 (Cons p3 (Cons p4 (Cons p5 (Cons p6 (Cons p7 Nil))))))) p0
        (Cons d1 (Cons d2 (Cons d3 (Cons d4 (Cons d5 (Cons d6 (Cons d7 Nil))))))) c Two

end
